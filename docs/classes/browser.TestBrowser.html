<!DOCTYPE html><html class="default no-js"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>TestBrowser | @bryntum/siesta</title><meta name="description" content="Documentation for @bryntum/siesta"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><link rel="stylesheet" href="../assets/custom.css"/><script async src="../assets/search.js" id="search-script"></script></head><body><script>document.body.classList.add(localStorage.getItem("tsd-theme") || "os")</script><header><div class="tsd-page-toolbar"><div class="container"><div class="table-wrap"><div class="table-cell" id="tsd-search" data-base=".."><div class="field"><label for="tsd-search-field" class="tsd-widget search no-caption">Search</label><input type="text" id="tsd-search-field"/></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="../index.html" class="title">@bryntum/siesta</a></div><div class="table-cell" id="tsd-widgets"><div id="tsd-filter"><a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a><div class="tsd-filter-group"><div class="tsd-select" id="tsd-filter-visibility"><span class="tsd-select-label">All</span><ul class="tsd-select-list"><li data-value="public">Public</li><li data-value="protected">Public/Protected</li><li data-value="private" class="selected">All</li></ul></div> <input type="checkbox" id="tsd-filter-inherited" checked/><label class="tsd-widget" for="tsd-filter-inherited">Inherited</label></div></div><a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a></div></div></div></div><div class="tsd-page-title"><div class="container"><ul class="tsd-breadcrumb"><li><a href="../modules.html">@bryntum/siesta</a></li><li><a href="../modules/browser.html">browser</a></li><li><a href="browser.TestBrowser.html">TestBrowser</a></li></ul><h1>Class TestBrowser</h1></div></div></header><div class="container container-main"><div class="row"><div class="col-8 col-content"><section class="tsd-panel tsd-comment"><div class="tsd-comment tsd-typography"><div class="lead">
<p>Test class for code running in the browser environment.</p>
</div><div><p>Please refer to the <a href="browser._internal_.TestDescriptorBrowser.html">TestDescriptorBrowser</a> documentation for the list of available config options.</p>
</div></div></section><section class="tsd-panel tsd-hierarchy"><h3>Hierarchy</h3><ul class="tsd-hierarchy"><li><span class="tsd-signature-type">TestBrowser</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">this</span><span class="tsd-signature-symbol">&gt;</span><ul class="tsd-hierarchy"><li><span class="target">TestBrowser</span></li></ul></li></ul></section><section class="tsd-panel-group tsd-index-group"><h2>Index</h2><section class="tsd-panel tsd-index-panel"><div class="tsd-index-content"><section class="tsd-index-section"><h3>Assertion modifiers</h3><ul class="tsd-index-list"><li class="tsd-kind-get-signature tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#not" class="tsd-kind-icon">not</a></li><li class="tsd-kind-get-signature tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#silent" class="tsd-kind-icon">silent</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#expect" class="tsd-kind-icon">expect</a></li></ul></section><section class="tsd-index-section"><h3>Asynchronicity</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#beginAsync" class="tsd-kind-icon">begin<wbr/>Async</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#endAsync" class="tsd-kind-icon">end<wbr/>Async</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#waitFor" class="tsd-kind-icon">wait<wbr/>For</a></li></ul></section><section class="tsd-index-section"><h3>Boolean comparison</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#false" class="tsd-kind-icon">false</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#notOk" class="tsd-kind-icon">not<wbr/>Ok</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#ok" class="tsd-kind-icon">ok</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#true" class="tsd-kind-icon">true</a></li></ul></section><section class="tsd-index-section"><h3>Dom assertions</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#elementPointIsReachable" class="tsd-kind-icon">element<wbr/>Point<wbr/>Is<wbr/>Reachable</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#elementValueIs" class="tsd-kind-icon">element<wbr/>Value<wbr/>Is</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#selectorExists" class="tsd-kind-icon">selector<wbr/>Exists</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#waitForSelector" class="tsd-kind-icon">wait<wbr/>For<wbr/>Selector</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#waitForSelectors" class="tsd-kind-icon">wait<wbr/>For<wbr/>Selectors</a></li></ul></section><section class="tsd-index-section"><h3>Dom helper methods</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#_" class="tsd-kind-icon">$</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#__" class="tsd-kind-icon">$$</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#getCaretPosition" class="tsd-kind-icon">get<wbr/>Caret<wbr/>Position</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#getSelectedText" class="tsd-kind-icon">get<wbr/>Selected<wbr/>Text</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#moveCaretPosition" class="tsd-kind-icon">move<wbr/>Caret<wbr/>Position</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#query" class="tsd-kind-icon">query</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#querySingleContext" class="tsd-kind-icon">query<wbr/>Single<wbr/>Context</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#selectText" class="tsd-kind-icon">select<wbr/>Text</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#setCaretPosition" class="tsd-kind-icon">set<wbr/>Caret<wbr/>Position</a></li></ul></section><section class="tsd-index-section"><h3>Equality</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#eq" class="tsd-kind-icon">eq</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#equal" class="tsd-kind-icon">equal</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#is" class="tsd-kind-icon">is</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isDeeply" class="tsd-kind-icon">is<wbr/>Deeply</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isNot" class="tsd-kind-icon">is<wbr/>Not</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isStrict" class="tsd-kind-icon">is<wbr/>Strict</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#ne" class="tsd-kind-icon">ne</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#notEqual" class="tsd-kind-icon">not<wbr/>Equal</a></li></ul></section><section class="tsd-index-section"><h3>Exceptions handling</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#doesNotThrow" class="tsd-kind-icon">does<wbr/>Not<wbr/>Throw</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#livesOk" class="tsd-kind-icon">lives<wbr/>Ok</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#throws" class="tsd-kind-icon">throws</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#throwsOk" class="tsd-kind-icon">throws<wbr/>Ok</a></li></ul></section><section class="tsd-index-section"><h3>Function calls assertions</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isCalled" class="tsd-kind-icon">is<wbr/>Called</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isCalledNTimes" class="tsd-kind-icon">is<wbr/>CalledNTimes</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isCalledOnce" class="tsd-kind-icon">is<wbr/>Called<wbr/>Once</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isntCalled" class="tsd-kind-icon">isnt<wbr/>Called</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#methodIsCalled" class="tsd-kind-icon">method<wbr/>Is<wbr/>Called</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#methodIsCalledNTimes" class="tsd-kind-icon">method<wbr/>Is<wbr/>CalledNTimes</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#methodIsntCalled" class="tsd-kind-icon">method<wbr/>Isnt<wbr/>Called</a></li></ul></section><section class="tsd-index-section"><h3>Fuzzy comparison</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#any" class="tsd-kind-icon">any</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#anyNumberApprox" class="tsd-kind-icon">any<wbr/>Number<wbr/>Approx</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#anyStringLike" class="tsd-kind-icon">any<wbr/>String<wbr/>Like</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isApprox" class="tsd-kind-icon">is<wbr/>Approx</a></li></ul></section><section class="tsd-index-section"><h3>Logging</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#debug" class="tsd-kind-icon">debug</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#error" class="tsd-kind-icon">error</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#info" class="tsd-kind-icon">info</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#log" class="tsd-kind-icon">log</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#warn" class="tsd-kind-icon">warn</a></li></ul></section><section class="tsd-index-section"><h3>Mocking</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#createSpy" class="tsd-kind-icon">create<wbr/>Spy</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#createSpyObj" class="tsd-kind-icon">create<wbr/>Spy<wbr/>Obj</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#spyOn" class="tsd-kind-icon">spy<wbr/>On</a></li></ul></section><section class="tsd-index-section"><h3>Numeric comparison</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isGE" class="tsd-kind-icon">isGE</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isGreater" class="tsd-kind-icon">is<wbr/>Greater</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isGreaterOrEqual" class="tsd-kind-icon">is<wbr/>Greater<wbr/>Or<wbr/>Equal</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isLE" class="tsd-kind-icon">isLE</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isLess" class="tsd-kind-icon">is<wbr/>Less</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isLessOrEqual" class="tsd-kind-icon">is<wbr/>Less<wbr/>Or<wbr/>Equal</a></li></ul></section><section class="tsd-index-section"><h3>Observable assertions</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#firesAtLeastNTimes" class="tsd-kind-icon">fires<wbr/>At<wbr/>LeastNTimes</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#firesOk" class="tsd-kind-icon">fires<wbr/>Ok</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#firesOnce" class="tsd-kind-icon">fires<wbr/>Once</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isntFired" class="tsd-kind-icon">isnt<wbr/>Fired</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#waitForEvent" class="tsd-kind-icon">wait<wbr/>For<wbr/>Event</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#willFireNTimes" class="tsd-kind-icon">will<wbr/>FireNTimes</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#wontFire" class="tsd-kind-icon">wont<wbr/>Fire</a></li></ul></section><section class="tsd-index-section"><h3>Other</h3><ul class="tsd-index-list"><li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#constructor" class="tsd-kind-icon">constructor</a></li><li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#logLevel" class="tsd-kind-icon">log<wbr/>Level</a></li><li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#testDescriptorClass" class="tsd-kind-icon">test<wbr/>Descriptor<wbr/>Class</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#contain" class="tsd-kind-icon">contain</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#initialize" class="tsd-kind-icon">initialize</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#notContain" class="tsd-kind-icon">not<wbr/>Contain</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#resolveObservable" class="tsd-kind-icon">resolve<wbr/>Observable</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#maybeNew" class="tsd-kind-icon">maybe<wbr/>New</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#new" class="tsd-kind-icon">new</a></li></ul></section><section class="tsd-index-section"><h3>String pattern matching</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#match" class="tsd-kind-icon">match</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#notMatch" class="tsd-kind-icon">not<wbr/>Match</a></li></ul></section><section class="tsd-index-section"><h3>Subtest management</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#afterEach" class="tsd-kind-icon">after<wbr/>Each</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#beforeEach" class="tsd-kind-icon">before<wbr/>Each</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#ddescribe" class="tsd-kind-icon">ddescribe</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#describe" class="tsd-kind-icon">describe</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#iit" class="tsd-kind-icon">iit</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#it" class="tsd-kind-icon">it</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#todo" class="tsd-kind-icon">todo</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#xit" class="tsd-kind-icon">xit</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#ddescribe-1" class="tsd-kind-icon">ddescribe</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#describe-1" class="tsd-kind-icon">describe</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#iit-1" class="tsd-kind-icon">iit</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#it-1" class="tsd-kind-icon">it</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#xdescribe" class="tsd-kind-icon">xdescribe</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#xit-1" class="tsd-kind-icon">xit</a></li></ul></section><section class="tsd-index-section"><h3>Typeguards</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isArray" class="tsd-kind-icon">is<wbr/>Array</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isBoolean" class="tsd-kind-icon">is<wbr/>Boolean</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isDate" class="tsd-kind-icon">is<wbr/>Date</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isFunction" class="tsd-kind-icon">is<wbr/>Function</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isInstanceOf" class="tsd-kind-icon">is<wbr/>Instance<wbr/>Of</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isMap" class="tsd-kind-icon">is<wbr/>Map</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isNumber" class="tsd-kind-icon">is<wbr/>Number</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isObject" class="tsd-kind-icon">is<wbr/>Object</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isRegExp" class="tsd-kind-icon">is<wbr/>Reg<wbr/>Exp</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isSet" class="tsd-kind-icon">is<wbr/>Set</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isString" class="tsd-kind-icon">is<wbr/>String</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isWeakMap" class="tsd-kind-icon">is<wbr/>Weak<wbr/>Map</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isWeakSet" class="tsd-kind-icon">is<wbr/>Weak<wbr/>Set</a></li></ul></section><section class="tsd-index-section"><h3>User action simulation</h3><ul class="tsd-index-list"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#click" class="tsd-kind-icon">click</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#doubleClick" class="tsd-kind-icon">double<wbr/>Click</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#dragBy" class="tsd-kind-icon">drag<wbr/>By</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#dragTo" class="tsd-kind-icon">drag<wbr/>To</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#keyDown" class="tsd-kind-icon">key<wbr/>Down</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#keyPress" class="tsd-kind-icon">key<wbr/>Press</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#keyUp" class="tsd-kind-icon">key<wbr/>Up</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#mouseDown" class="tsd-kind-icon">mouse<wbr/>Down</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#mouseUp" class="tsd-kind-icon">mouse<wbr/>Up</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#moveMouseBy" class="tsd-kind-icon">move<wbr/>Mouse<wbr/>By</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#moveMouseTo" class="tsd-kind-icon">move<wbr/>Mouse<wbr/>To</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#rightClick" class="tsd-kind-icon">right<wbr/>Click</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#type" class="tsd-kind-icon">type</a></li></ul></section></div></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Assertion modifiers</h2><section class="tsd-panel tsd-member tsd-kind-get-signature tsd-parent-kind-class tsd-is-inherited"><a id="not" class="tsd-anchor"></a><h3>not</h3><ul class="tsd-signatures tsd-kind-get-signature tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">get</span> not<span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">this</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).not</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L373">siesta/src/siesta/test/Test.ts:373</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is an <em>assertion modifier</em>. It returns the test instance itself, but the next added assertion is specialized
in a certain way.</p>
</div><div><p>This modifier &quot;inverts&quot; the assertion, so it obtains a negative semantic.</p>
<p>For example, there&#39;s a <a href="browser.TestBrowser.html#equal">equal</a> assertion which passes, when provided objects are the structurally the same.
Inverted assertion will pass when provided objects are structurally different:</p>
<pre><code class="language-javascript"><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">equal</span><span class="hl-0">(</span><span class="hl-7">1</span><span class="hl-0">, </span><span class="hl-7">1</span><span class="hl-0">) </span><span class="hl-5">// passes</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-2">not</span><span class="hl-0">.</span><span class="hl-3">equal</span><span class="hl-0">(</span><span class="hl-7">1</span><span class="hl-0">, </span><span class="hl-7">2</span><span class="hl-0">) </span><span class="hl-5">// passes</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-2">not</span><span class="hl-0">.</span><span class="hl-3">equal</span><span class="hl-0">(</span><span class="hl-7">1</span><span class="hl-0">, </span><span class="hl-7">1</span><span class="hl-0">) </span><span class="hl-5">// fails</span>
</code></pre>
<p>Any assertion can be negated in this way, except the ones related to waiting, like <a href="browser.TestBrowser.html#waitFor">waitFor</a>.</p>
</div><dl class="tsd-comment-tags"><dt>category</dt><dd><p>Assertion modifiers</p>
</dd></dl></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">this</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-get-signature tsd-parent-kind-class tsd-is-inherited"><a id="silent" class="tsd-anchor"></a><h3>silent</h3><ul class="tsd-signatures tsd-kind-get-signature tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">get</span> silent<span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">this</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).silent</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L319">siesta/src/siesta/test/Test.ts:319</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is an <em>assertion modifier</em>. It returns the test instance itself, but the next added assertion is specialized
in a certain way.</p>
</div><div><p>This modifier makes the assertion &quot;silent&quot; - it will only appear in the test log if it fails.</p>
<p>Note, that by default, the console output already hides passed assertions. The dashboard interface however
shows them.</p>
<p>This modifier causes the passed assertion to be physically excluded from the log, so it won&#39;t appear in any
kind of user interface or report.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-2">silent</span><span class="hl-0">.</span><span class="hl-3">equal</span><span class="hl-0">(</span><span class="hl-7">1</span><span class="hl-0">, </span><span class="hl-7">1</span><span class="hl-0">) </span><span class="hl-5">// passes, assertion excluded from the log</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-2">silent</span><span class="hl-0">.</span><span class="hl-3">equal</span><span class="hl-0">(</span><span class="hl-7">1</span><span class="hl-0">, </span><span class="hl-7">2</span><span class="hl-0">) </span><span class="hl-5">// fails, assertion will be included in the log as usual</span>
</code></pre>
<p>Any assertion can be modified in this way.</p>
</div><dl class="tsd-comment-tags"><dt>category</dt><dd><p>Assertion modifiers</p>
</dd></dl></div><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">this</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="expect" class="tsd-anchor"></a><h3>expect</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">expect<span class="tsd-signature-symbol">(</span>received<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="index._internal_.Expectation.html" class="tsd-signature-type" data-tsd-kind="Class">Expectation</a></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).expect</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L211">siesta/src/siesta/test/Test.ts:211</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This method returns an &quot;expectation&quot; instance, which can be used to check various assertions about the passed value.</p>
</div><div><p>Every expectation has a special property <code>not</code>, that contains another expectation, but with the negated meaning.</p>
<p>For example:</p>
<pre><code class="language-ts"><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">expect</span><span class="hl-0">(</span><span class="hl-7">1</span><span class="hl-0">).</span><span class="hl-3">toBe</span><span class="hl-0">(</span><span class="hl-7">1</span><span class="hl-0">)</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">expect</span><span class="hl-0">(</span><span class="hl-7">1</span><span class="hl-0">).</span><span class="hl-2">not</span><span class="hl-0">.</span><span class="hl-3">toBe</span><span class="hl-0">(</span><span class="hl-7">2</span><span class="hl-0">)</span><br/><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">expect</span><span class="hl-0">(</span><span class="hl-4">&#39;Foo&#39;</span><span class="hl-0">).</span><span class="hl-3">toContain</span><span class="hl-0">(</span><span class="hl-4">&#39;oo&#39;</span><span class="hl-0">)</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">expect</span><span class="hl-0">(</span><span class="hl-4">&#39;Foo&#39;</span><span class="hl-0">).</span><span class="hl-2">not</span><span class="hl-0">.</span><span class="hl-3">toContain</span><span class="hl-0">(</span><span class="hl-4">&#39;bar&#39;</span><span class="hl-0">)</span>
</code></pre>
<p>Please refer to the documentation of the <a href="index._internal_.Expectation.html">Expectation</a> class for the list of available methods.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>received: <span class="tsd-signature-type">unknown</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <a href="index._internal_.Expectation.html" class="tsd-signature-type" data-tsd-kind="Class">Expectation</a></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Asynchronicity</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="beginAsync" class="tsd-anchor"></a><h3>begin<wbr/>Async</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">begin<wbr/>Async<span class="tsd-signature-symbol">(</span>timeout<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).beginAsync</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionAsync.tsx#L192">siesta/src/siesta/test/assertion/AssertionAsync.tsx:192</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Normally, to test the asynchronous code, you just make your test function <code>async</code> and <code>await</code> on any asynchronous
method call inside of it:</p>
</div><div><pre><code class="language-javascript"><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">it</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;@bryntum/siesta/index.js&quot;</span><br/><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">MyClass</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;my-lib&quot;</span><br/><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Testing asynchronous code should work&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">myClass</span><span class="hl-0">       = </span><span class="hl-6">new</span><span class="hl-0"> </span><span class="hl-3">MyClass</span><span class="hl-0">()</span><br/><br/><span class="hl-0">    </span><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">myClass</span><span class="hl-0">.</span><span class="hl-3">asyncMethod</span><span class="hl-0">(</span><span class="hl-4">&#39;do something&#39;</span><span class="hl-0">)</span><br/><span class="hl-0">})</span>
</code></pre>
<p>However, for example if code is using callbacks, you might not have a <code>Promise</code> instance to <code>await</code> for.</p>
<p>In such case, use this method to indicate the beginning of the &quot;asynchronous gap&quot; in the code flow. Each gap should be finalized
with the <a href="browser.TestBrowser.html#endAsync">endAsync</a> call within the <code>timeout</code> milliseconds, otherwise a failed assertion will be reported.</p>
<p>The test will wait for all asynchronous gaps to complete before it will finalize.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">it</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;@bryntum/siesta/index.js&quot;</span><br/><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">MyClass</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;my-lib&quot;</span><br/><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Testing asynchronous code should work&#39;</span><span class="hl-0">, </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">myClass</span><span class="hl-0">        = </span><span class="hl-6">new</span><span class="hl-0"> </span><span class="hl-3">MyClass</span><span class="hl-0">()</span><br/><br/><span class="hl-0">    </span><span class="hl-5">// indicate async gap starts</span><br/><span class="hl-0">    </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">async</span><span class="hl-0">          = </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">beginAsync</span><span class="hl-0">()</span><br/><br/><span class="hl-0">    </span><span class="hl-2">myClass</span><span class="hl-0">.</span><span class="hl-3">asyncMethodWithCallback</span><span class="hl-0">(() </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">        </span><span class="hl-5">// indicate async gap completes</span><br/><span class="hl-0">        </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">endAsync</span><span class="hl-0">(</span><span class="hl-2">async</span><span class="hl-0">)</span><br/><span class="hl-0">    })</span><br/><span class="hl-0">})</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>timeout: <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> = ...</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">number</span></h4><div><p>The &quot;gap id&quot; opaque object, which should be passed to the <a href="browser.TestBrowser.html#endAsync">endAsync</a> call.</p>
</div></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="endAsync" class="tsd-anchor"></a><h3>end<wbr/>Async</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">end<wbr/>Async<span class="tsd-signature-symbol">(</span>gapId<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).endAsync</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionAsync.tsx#L228">siesta/src/siesta/test/assertion/AssertionAsync.tsx:228</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This method finalizes the &quot;asynchronous gap&quot; started with <a href="browser.TestBrowser.html#beginAsync">beginAsync</a>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>gapId: <span class="tsd-signature-type">number</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The gap id to finalize (returned by the <a href="browser.TestBrowser.html#beginAsync">beginAsync</a> method)</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="waitFor" class="tsd-anchor"></a><h3>wait<wbr/>For</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">wait<wbr/>For<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>waiting<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span></li><li class="tsd-signature tsd-kind-icon">wait<wbr/>For<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>waiting<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">OrPromise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span></li><li class="tsd-signature tsd-kind-icon">wait<wbr/>For<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>waiting<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/index._internal_.html#WaitForOptions" class="tsd-signature-type" data-tsd-kind="Type alias">WaitForOptions</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).waitFor</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionAsync.tsx#L293">siesta/src/siesta/test/assertion/AssertionAsync.tsx:293</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes, if waiting for some condition has completed successfully, within the expected timeout.</p>
</div><div><p>The condition to wait for should be specified as a <code>checker</code> function. It can be <code>async</code> if needed (return a <code>Promise</code>).
For the waiting to complete, the condition checker should return some &quot;truthy&quot; value, like <code>true</code>, <code>1</code>, <code>&#39;some_string&#39;</code>, etc.
That value (wrapped in a <code>Promise</code>) will be returned from the <code>waitFor</code> method itself.</p>
<p>Alternatively, this method can just await for certain time.</p>
<p>This method has 3 overloads:</p>
<ul>
<li>one for waiting the specified time</li>
<li>one when checker function is provided directly in the argument</li>
<li>one with <a href="../modules/index._internal_.html#WaitForOptions">options</a> argument. In this overload, all options are available, for example,
one can customize the maximum time to wait - <code>timeout</code>.</li>
</ul>
<p>Note, this method is <code>async</code>. Don&#39;t forget to <code>await</code> on it. .</p>
<p>For example:</p>
<pre><code class="language-ts"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">waitFor</span><span class="hl-0">(() </span><span class="hl-6">=&gt;</span><span class="hl-11"> /Special/</span><span class="hl-0">.</span><span class="hl-3">test</span><span class="hl-0">(</span><span class="hl-2">document</span><span class="hl-0">.</span><span class="hl-2">title</span><span class="hl-0">))</span><br/><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">waitFor</span><span class="hl-0">({</span><br/><span class="hl-0">    </span><span class="hl-3">condition</span><span class="hl-2">    :</span><span class="hl-0"> () </span><span class="hl-6">=&gt;</span><span class="hl-0"> </span><span class="hl-2">document</span><span class="hl-0">.</span><span class="hl-2">readyState</span><span class="hl-0"> === </span><span class="hl-4">&#39;complete&#39;</span><span class="hl-0">),</span><br/><span class="hl-0">    </span><span class="hl-2">timeout      :</span><span class="hl-0"> </span><span class="hl-7">30000</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-2">interval     :</span><span class="hl-0"> </span><span class="hl-7">1000</span><br/><span class="hl-0">})</span><br/><br/><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">elements</span><span class="hl-0"> = </span><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">waitFor</span><span class="hl-0">(() </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">els</span><span class="hl-0">    = </span><span class="hl-2">document</span><span class="hl-0">.</span><span class="hl-3">querySelectorAll</span><span class="hl-0">(</span><span class="hl-4">&#39;.some_class&#39;</span><span class="hl-0">)</span><br/><br/><span class="hl-0">    </span><span class="hl-1">return</span><span class="hl-0"> </span><span class="hl-2">els</span><span class="hl-0">.</span><span class="hl-2">length</span><span class="hl-0"> &gt; </span><span class="hl-7">0</span><span class="hl-0"> ? </span><span class="hl-2">els</span><span class="hl-0"> : </span><span class="hl-6">null</span><br/><span class="hl-0">})</span>
</code></pre>
<p>IMPORTANT: To avoid race conditions, always start waiting for certain event, <em>before</em> triggering it.
See the trigger option in the <a href="../modules/index._internal_.html#WaitForOptions">WaitForOptions</a> object for more details.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>R</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>waiting: <span class="tsd-signature-type">number</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).waitFor</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionAsync.tsx#L294">siesta/src/siesta/test/assertion/AssertionAsync.tsx:294</a></li></ul></aside><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>R</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>waiting: <span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">OrPromise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span></h5><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">OrPromise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">OrPromise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></li></ul></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).waitFor</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionAsync.tsx#L295">siesta/src/siesta/test/assertion/AssertionAsync.tsx:295</a></li></ul></aside><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>R</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>waiting: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/index._internal_.html#WaitForOptions" class="tsd-signature-type" data-tsd-kind="Type alias">WaitForOptions</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">R</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Boolean comparison</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="false" class="tsd-anchor"></a><h3>false</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">false<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).false</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L102">siesta/src/siesta/test/assertion/AssertionCompare.tsx:102</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if provided value is &quot;falsy&quot; - <code>false</code>, <code>0</code>, <code>&#39;&#39;</code> etc.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="notOk" class="tsd-anchor"></a><h3>not<wbr/>Ok</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">not<wbr/>Ok<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).notOk</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L136">siesta/src/siesta/test/assertion/AssertionCompare.tsx:136</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Backward compatibility alias for <a href="browser.TestBrowser.html#false">false</a></p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="ok" class="tsd-anchor"></a><h3>ok</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">ok<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).ok</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L125">siesta/src/siesta/test/assertion/AssertionCompare.tsx:125</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Backward compatibility alias for <a href="browser.TestBrowser.html#true">true</a></p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="true" class="tsd-anchor"></a><h3>true</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">true<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).true</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L113">siesta/src/siesta/test/assertion/AssertionCompare.tsx:113</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if provided value is &quot;truthy&quot; - <code>true</code>, <code>1</code>, <code>&#39;non_empty_string&#39;</code> etc</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Dom assertions</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="elementPointIsReachable" class="tsd-anchor"></a><h3>element<wbr/>Point<wbr/>Is<wbr/>Reachable</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">element<wbr/>Point<wbr/>Is<wbr/>Reachable<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li><li class="tsd-signature tsd-kind-icon">element<wbr/>Point<wbr/>Is<wbr/>Reachable<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, options<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-symbol">{ </span>allowChildren<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol">; </span>offset<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> }</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).elementPointIsReachable</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionElement.tsx#L47">siesta/src/siesta/test/assertion/AssertionElement.tsx:47</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the given <code>offset</code> point of the <code>target</code> element is directly reachable by the user, i.e.
it is not covered with some other element. If the <code>offset</code> is not provided, the center of the element is tested.
The test is performed using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/elementFromPoint">document.getElementFromPoint()</a> method.</p>
</div><div><p>Usually it is fine if the element is covered with one of its children - it is still considered reachable.
This behaviour is controlled with the <code>allowChildren</code> option, by default it is set to <code>true</code>.</p>
<p>This method has 2 overloads, one simplified and one with options.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).elementPointIsReachable</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionElement.tsx#L50">siesta/src/siesta/test/assertion/AssertionElement.tsx:50</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>options: <a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-symbol">{ </span>allowChildren<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol">; </span>offset<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> }</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="elementValueIs" class="tsd-anchor"></a><h3>element<wbr/>Value<wbr/>Is</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">element<wbr/>Value<wbr/>Is<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).elementValueIs</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionElement.tsx#L124">siesta/src/siesta/test/assertion/AssertionElement.tsx:124</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes, if the <code>value</code> property of the <code>target</code> element is strictly equal to the given <code>value</code>
argument. No assumption is made about what is the target element, but usually it should be <code>&lt;input&gt;</code> or
<code>&lt;textarea&gt;</code>.</p>
</div><div><p>For example:</p>
<pre><code class="language-javascript"><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">elementValuesIs</span><span class="hl-0">(</span><span class="hl-4">&#39;#input1&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;Need this text&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;Correct text in the input field&#39;</span><span class="hl-0">)</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>value: <span class="tsd-signature-type">string</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="selectorExists" class="tsd-anchor"></a><h3>selector<wbr/>Exists</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">selector<wbr/>Exists<span class="tsd-signature-symbol">(</span>selector<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).selectorExists</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionElement.tsx#L153">siesta/src/siesta/test/assertion/AssertionElement.tsx:153</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the given CSS / ActionTarget selector is found in the DOM.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>selector: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>A CSS or ActionTarget selector</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The description for the assertion</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="waitForSelector" class="tsd-anchor"></a><h3>wait<wbr/>For<wbr/>Selector</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">wait<wbr/>For<wbr/>Selector<span class="tsd-signature-symbol">(</span>selector<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, root<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li><li class="tsd-signature tsd-kind-icon">wait<wbr/>For<wbr/>Selector<span class="tsd-signature-symbol">(</span>selector<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, options<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-symbol">{ </span>root<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a><span class="tsd-signature-symbol">; </span>timeout<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> }</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).waitForSelector</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionElement.tsx#L195">siesta/src/siesta/test/assertion/AssertionElement.tsx:195</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertions passes if waiting for the given <code>selector</code> completes within <code>timeout</code>.
If no <code>timeout</code> is given <a href="index._internal_.TestDescriptor.html#defaultTimeout">TestDescriptor.defaultTimeout</a> is used. One can also specify
a <code>root</code> element, from which the query will be starting.</p>
</div><div><p>This method has 2 overloads</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">waitForSelector</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class&#39;</span><span class="hl-0">, { </span><span class="hl-2">root :</span><span class="hl-0"> </span><span class="hl-4">&#39;.root&#39;</span><span class="hl-0">, </span><span class="hl-2">timeout :</span><span class="hl-0"> </span><span class="hl-7">5000</span><span class="hl-0"> })</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>selector: <span class="tsd-signature-type">string</span></h5></li><li><h5>root: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).waitForSelector</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionElement.tsx#L196">siesta/src/siesta/test/assertion/AssertionElement.tsx:196</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>selector: <span class="tsd-signature-type">string</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> options: <span class="tsd-signature-symbol">{ </span>root<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a><span class="tsd-signature-symbol">; </span>timeout<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> }</span></h5><ul class="tsd-parameters"><li class="tsd-parameter"><h5><span class="tsd-flag ts-flagOptional">Optional</span> root<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>include</p>
</div></div></li><li class="tsd-parameter"><h5><span class="tsd-flag ts-flagOptional">Optional</span> timeout<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">number</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>include</p>
</div></div></li></ul></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="waitForSelectors" class="tsd-anchor"></a><h3>wait<wbr/>For<wbr/>Selectors</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">wait<wbr/>For<wbr/>Selectors<span class="tsd-signature-symbol">(</span>selector<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span>, root<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li><li class="tsd-signature tsd-kind-icon">wait<wbr/>For<wbr/>Selectors<span class="tsd-signature-symbol">(</span>selector<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span>, options<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-symbol">{ </span>root<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a><span class="tsd-signature-symbol">; </span>timeout<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> }</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).waitForSelectors</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionElement.tsx#L256">siesta/src/siesta/test/assertion/AssertionElement.tsx:256</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertions passes if waiting for the given <code>selector</code> completes within <code>timeout</code>.
If no <code>timeout</code> is given <a href="index._internal_.TestDescriptor.html#defaultTimeout">TestDescriptor.defaultTimeout</a> is used. One can also specify
a <code>root</code> element, from which the query will be starting.</p>
</div><div><p>This method has 2 overloads</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">waitForSelector</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class&#39;</span><span class="hl-0">, { </span><span class="hl-2">root :</span><span class="hl-0"> </span><span class="hl-4">&#39;.root&#39;</span><span class="hl-0">, </span><span class="hl-2">timeout :</span><span class="hl-0"> </span><span class="hl-7">5000</span><span class="hl-0"> })</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>selector: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span></h5></li><li><h5>root: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).waitForSelectors</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionElement.tsx#L257">siesta/src/siesta/test/assertion/AssertionElement.tsx:257</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>selector: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> options: <span class="tsd-signature-symbol">{ </span>root<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a><span class="tsd-signature-symbol">; </span>timeout<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> }</span></h5><ul class="tsd-parameters"><li class="tsd-parameter"><h5><span class="tsd-flag ts-flagOptional">Optional</span> root<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>include</p>
</div></div></li><li class="tsd-parameter"><h5><span class="tsd-flag ts-flagOptional">Optional</span> timeout<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">number</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>include</p>
</div></div></li></ul></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Dom helper methods</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="_" class="tsd-anchor"></a><h3>$</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">$<span class="tsd-signature-symbol">(</span>query<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, root<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Document</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Element</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).$</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L455">siesta/src/siesta/simulate/UserAgent.tsx:455</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Performs a query in the DOM using <a href="browser.TestBrowser.html#query">query</a> method and returns the 1st element from the results.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>query: <span class="tsd-signature-type">string</span></h5></li><li><h5>root: <span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Document</span><span class="tsd-signature-symbol"> = ...</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Element</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="__" class="tsd-anchor"></a><h3>$$</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">$$<span class="tsd-signature-symbol">(</span>query<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, root<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Document</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol">[]</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).$$</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L467">siesta/src/siesta/simulate/UserAgent.tsx:467</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Synonym for <a href="browser.TestBrowser.html#query">query</a>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>query: <span class="tsd-signature-type">string</span></h5></li><li><h5>root: <span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Document</span><span class="tsd-signature-symbol"> = ...</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol">[]</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="getCaretPosition" class="tsd-anchor"></a><h3>get<wbr/>Caret<wbr/>Position</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">get<wbr/>Caret<wbr/>Position<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).getCaretPosition</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/browser/TextSelectionHelpers.ts#L60">siesta/src/siesta/test/browser/TextSelectionHelpers.ts:60</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This helper method returns an index of the caret position (0-based) in the given <code>target</code> element</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">number</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="getSelectedText" class="tsd-anchor"></a><h3>get<wbr/>Selected<wbr/>Text</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">get<wbr/>Selected<wbr/>Text<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).getSelectedText</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/browser/TextSelectionHelpers.ts#L29">siesta/src/siesta/test/browser/TextSelectionHelpers.ts:29</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This helper method returns a selected text in the given <code>target</code> element</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">string</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="moveCaretPosition" class="tsd-anchor"></a><h3>move<wbr/>Caret<wbr/>Position</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">move<wbr/>Caret<wbr/>Position<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, delta<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).moveCaretPosition</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/browser/TextSelectionHelpers.ts#L90">siesta/src/siesta/test/browser/TextSelectionHelpers.ts:90</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This helper method moves the caret position in the given <code>target</code> element by the <code>delta</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>delta: <span class="tsd-signature-type">number</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="query" class="tsd-anchor"></a><h3>query</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">query<span class="tsd-signature-symbol">(</span>query<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, root<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Document</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">ShadowRoot</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol">[]</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).query</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L417">siesta/src/siesta/simulate/UserAgent.tsx:417</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Performs a query in the DOM, by default it is a regular CSS query with extra capabilities.</p>
</div><div><p>Notably, the <code>:contains(text)</code> pseudo is supported. It matches, if the text content of the element
contains the provided <code>text</code>.</p>
<p>Also, the <code>-&gt;</code> characters split the query into segments, and each segment matches inside a &quot;context&quot;.
Context can be either an iframe or a web component shadow DOM. Simply put, the <code>-&gt;</code> symbol marks the boundary
of the iframe/web component. Web component need to have &quot;opened&quot; shadow DOM for query to work.</p>
<p>For example:</p>
<pre><code><span class="hl-5">// matches the `body` element of all iframes with `my-frame` CSS class</span><br/><span class="hl-0">.</span><span class="hl-2">my</span><span class="hl-0">-</span><span class="hl-2">frame</span><span class="hl-0"> -&gt; </span><span class="hl-2">body</span><br/><br/><span class="hl-5">// matches the `body` element of all iframes with `nested-frame` CSS class, which are in turn contained</span><br/><span class="hl-5">// inside the iframes with `my-frame` class</span><br/><span class="hl-0">.</span><span class="hl-2">my</span><span class="hl-0">-</span><span class="hl-2">frame</span><span class="hl-0"> -&gt; .</span><span class="hl-2">nested</span><span class="hl-0">-</span><span class="hl-2">frame</span><span class="hl-0"> -&gt; </span><span class="hl-2">body</span><br/><br/><span class="hl-5">// matches the elements with `target-class` CSS class, which are inside the shadow DOM of the</span><br/><span class="hl-5">// web component element with `my-web-comp1` class</span><br/><span class="hl-0">.</span><span class="hl-2">my</span><span class="hl-0">-</span><span class="hl-2">web</span><span class="hl-0">-</span><span class="hl-2">comp1</span><span class="hl-0"> -&gt; .</span><span class="hl-2">target</span><span class="hl-0">-</span><span class="hl-6">class</span>
</code></pre>
<p>This method uses <a href="browser.TestBrowser.html#querySingleContext">querySingleContext</a> to perform simple query inside a single context.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>query: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>An enhanced CSS selector</p>
</div></div></li><li><h5>root: <span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Document</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">ShadowRoot</span><span class="tsd-signature-symbol"> = ...</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The root DOM element (or a <code>Document</code>) from which to start the query. Optional, by default
its the <code>document</code> of the test context.</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol">[]</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="querySingleContext" class="tsd-anchor"></a><h3>query<wbr/>Single<wbr/>Context</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">query<wbr/>Single<wbr/>Context<span class="tsd-signature-symbol">(</span>query<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, root<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Document</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">ShadowRoot</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol">[]</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).querySingleContext</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L376">siesta/src/siesta/simulate/UserAgent.tsx:376</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>You probably don&#39;t need to use this method in your tests. Use <a href="browser.TestBrowser.html#query">query</a> instead.
This method can be overridden by the subclass, to provide some extra query syntax, features etc.</p>
</div><div><p>Performs a query in the DOM, by default it is a regular CSS query. Query is performed inside a single DOM context
(single iframe or single web component). See <a href="browser.TestBrowser.html#query">query</a> for cross-context querying capabilities.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>query: <span class="tsd-signature-type">string</span></h5></li><li><h5>root: <span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Document</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">ShadowRoot</span><span class="tsd-signature-symbol"> = ...</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Element</span><span class="tsd-signature-symbol">[]</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="selectText" class="tsd-anchor"></a><h3>select<wbr/>Text</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">select<wbr/>Text<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, start<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">number</span>, end<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).selectText</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/browser/TextSelectionHelpers.ts#L46">siesta/src/siesta/test/browser/TextSelectionHelpers.ts:46</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This helper method selects text in the given <code>target</code> element, starting from the index <code>start</code> (0-based)
till the index <code>end</code></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> start: <span class="tsd-signature-type">number</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> end: <span class="tsd-signature-type">number</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="setCaretPosition" class="tsd-anchor"></a><h3>set<wbr/>Caret<wbr/>Position</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">set<wbr/>Caret<wbr/>Position<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, caretPos<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).setCaretPosition</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/browser/TextSelectionHelpers.ts#L75">siesta/src/siesta/test/browser/TextSelectionHelpers.ts:75</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This helper method sets the index of the caret position (0-based) in the given <code>target</code> element.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>caretPos: <span class="tsd-signature-type">number</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Equality</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="eq" class="tsd-anchor"></a><h3>eq</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">eq<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>received<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).eq</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L235">siesta/src/siesta/test/assertion/AssertionCompare.tsx:235</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>A shorter alias for <a href="browser.TestBrowser.html#equal">equal</a></p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>received: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>expected: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="equal" class="tsd-anchor"></a><h3>equal</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">equal<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>received<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).equal</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L266">siesta/src/siesta/test/assertion/AssertionCompare.tsx:266</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received (left) and expected (right) values are &quot;structurally&quot; equal, the
so called &quot;deep&quot; equality.</p>
</div><div><p><code>Map</code>, <code>Set</code> and other native JavaScript data types are supported. Currently these objects are compared
by their content, any extra properties, set on them, will not be compared. We plan to support this
use case if there will be a demand for it.</p>
<p>Cyclic data structures are supported. Fuzzy matchers, like <a href="browser.TestBrowser.html#any">any</a>, <a href="browser.TestBrowser.html#anyNumberApprox">anyNumberApprox</a>, etc are supported
inside the <code>expected</code> data.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>received: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>expected: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="is" class="tsd-anchor"></a><h3>is</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>received<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).is</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L415">siesta/src/siesta/test/assertion/AssertionCompare.tsx:415</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is Siesta 5 backward compatible assertion, which performs comparison of the 2 values, using the <code>==</code> comparison.
So, <code>null</code> will be equal to <code>undefined</code>, <code>4</code> to <code>&quot;4&quot;</code> and so on. As an additional quirk, <code>Date</code> instances
are compared structurally, by their time, instead of by reference.</p>
</div><div><p>The fuzzy matchers, like <a href="browser.TestBrowser.html#any">any</a>, <a href="browser.TestBrowser.html#anyNumberApprox">anyNumberApprox</a>, etc are supported for the <code>expected</code> value.</p>
<p>It is recommended to use the deep structural equality instead of this assertion, check <a href="browser.TestBrowser.html#equal">equal</a> and its
shortcut alias <a href="browser.TestBrowser.html#eq">eq</a>.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>received: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>expected: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="isDeeply" class="tsd-anchor"></a><h3>is<wbr/>Deeply</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Deeply<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>value1<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, value2<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isDeeply</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L295">siesta/src/siesta/test/assertion/AssertionCompare.tsx:295</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Backward compatible alias for <a href="browser.TestBrowser.html#equal">equal</a></p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value1: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>value2: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="isNot" class="tsd-anchor"></a><h3>is<wbr/>Not</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Not<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>value1<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, value2<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isNot</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L434">siesta/src/siesta/test/assertion/AssertionCompare.tsx:434</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>The negated version of <a href="browser.TestBrowser.html#is">is</a>. Can be also written as <code>t.not.is()</code>. See <a href="browser.TestBrowser.html#not">t.not</a> for details.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value1: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>value2: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="isStrict" class="tsd-anchor"></a><h3>is<wbr/>Strict</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Strict<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>value1<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, value2<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isStrict</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L396">siesta/src/siesta/test/assertion/AssertionCompare.tsx:396</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received and expected values are equal, as defined by the <code>===</code> operator.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value1: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>value2: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="ne" class="tsd-anchor"></a><h3>ne</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">ne<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>value1<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, value2<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).ne</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L244">siesta/src/siesta/test/assertion/AssertionCompare.tsx:244</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>A shorter alias for <a href="browser.TestBrowser.html#notEqual">notEqual</a>. Can be also written as <code>t.not.eq()</code>, see <a href="browser.TestBrowser.html#not">t.not</a> for details.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value1: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>value2: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="notEqual" class="tsd-anchor"></a><h3>not<wbr/>Equal</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">not<wbr/>Equal<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>value1<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, value2<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).notEqual</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L282">siesta/src/siesta/test/assertion/AssertionCompare.tsx:282</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received (left) and expected (right) values are &quot;structurally&quot; <em>not</em> equal, the
so called &quot;deep&quot; inequality.</p>
</div><div><p>See <a href="browser.TestBrowser.html#equal">equal</a> for details.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value1: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>value2: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Exceptions handling</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="doesNotThrow" class="tsd-anchor"></a><h3>does<wbr/>Not<wbr/>Throw</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">does<wbr/>Not<wbr/>Throw<span class="tsd-signature-symbol">(</span>func<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).doesNotThrow</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionException.tsx#L221">siesta/src/siesta/test/assertion/AssertionException.tsx:221</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes, if the provided function <code>func</code> does not throw any exceptions.</p>
</div><div><pre><code class="language-javascript"><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">it</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;@bryntum/siesta/index.js&quot;</span><br/><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Test section&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">doesNotThrow</span><span class="hl-0">(() </span><span class="hl-6">=&gt;</span><span class="hl-0"> {}, </span><span class="hl-4">&#39;No exceptions thrown&#39;</span><span class="hl-0">)</span><br/><span class="hl-0">})</span>
</code></pre>
<p>The <code>func</code> function may be <code>async</code> or return <code>Promise</code>. In such case, do not
forget to <code>await</code> on the assertion method itself:</p>
<pre><code class="language-javascript"><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">it</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;@bryntum/siesta/index.js&quot;</span><br/><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Test section&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">doesNotThrow</span><span class="hl-0">(</span><span class="hl-6">async</span><span class="hl-0"> () </span><span class="hl-6">=&gt;</span><span class="hl-0"> {}, </span><span class="hl-4">&#39;No exceptions thrown&#39;</span><span class="hl-0">)</span><br/><span class="hl-0">})</span>
</code></pre>
<p>See also <a href="browser.TestBrowser.html#throws">throws</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>func: <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="livesOk" class="tsd-anchor"></a><h3>lives<wbr/>Ok</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">lives<wbr/>Ok<span class="tsd-signature-symbol">(</span>func<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).livesOk</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionException.tsx#L244">siesta/src/siesta/test/assertion/AssertionException.tsx:244</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Backward compatible alias for <a href="browser.TestBrowser.html#doesNotThrow">doesNotThrow</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>func: <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="throws" class="tsd-anchor"></a><h3>throws</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">throws<span class="tsd-signature-symbol">(</span>func<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span>, pattern<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">RegExp</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).throws</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionException.tsx#L190">siesta/src/siesta/test/assertion/AssertionException.tsx:190</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes, if the provided function <code>func</code> throws an exception, which
stringifies to the <code>pattern</code>.</p>
</div><div><pre><code class="language-javascript"><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">it</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;@bryntum/siesta/index.js&quot;</span><br/><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Test section&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">throws</span><span class="hl-0">(() </span><span class="hl-6">=&gt;</span><span class="hl-0"> </span><span class="hl-2">throw</span><span class="hl-0"> </span><span class="hl-6">new</span><span class="hl-0"> </span><span class="hl-8">Error</span><span class="hl-0">(</span><span class="hl-4">&quot;oops&quot;</span><span class="hl-0">),</span><span class="hl-11"> /oop/</span><span class="hl-6">i</span><span class="hl-0">, </span><span class="hl-4">&#39;Correct exception thrown&#39;</span><span class="hl-0">)</span><br/><span class="hl-0">})</span>
</code></pre>
<p>The <code>func</code> function may be <code>async</code> or return <code>Promise</code>. In such case, do not
forget to <code>await</code> on the assertion method itself:</p>
<pre><code class="language-javascript"><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">it</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;@bryntum/siesta/index.js&quot;</span><br/><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Test section&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">throws</span><span class="hl-0">(</span><span class="hl-6">async</span><span class="hl-0"> () </span><span class="hl-6">=&gt;</span><span class="hl-0"> </span><span class="hl-2">throw</span><span class="hl-0"> </span><span class="hl-6">new</span><span class="hl-0"> </span><span class="hl-8">Error</span><span class="hl-0">(</span><span class="hl-4">&quot;oops&quot;</span><span class="hl-0">),</span><span class="hl-11"> /oop/</span><span class="hl-6">i</span><span class="hl-0">, </span><span class="hl-4">&#39;Correct exception thrown&#39;</span><span class="hl-0">)</span><br/><span class="hl-0">})</span>
</code></pre>
<p>See also <a href="browser.TestBrowser.html#doesNotThrow">doesNotThrow</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>func: <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The function to call. May be <code>async</code> or return <code>Promise</code>. In such case, do not
forget to <code>await</code> on the assertion method itself:</p>
</div></div></li><li><h5>pattern: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">RegExp</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="throwsOk" class="tsd-anchor"></a><h3>throws<wbr/>Ok</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">throws<wbr/>Ok<span class="tsd-signature-symbol">(</span>func<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span>, pattern<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">RegExp</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).throwsOk</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionException.tsx#L233">siesta/src/siesta/test/assertion/AssertionException.tsx:233</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Backward compatible alias for <a href="browser.TestBrowser.html#throws">throws</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>func: <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>pattern: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">RegExp</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Function calls assertions</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="isCalled" class="tsd-anchor"></a><h3>is<wbr/>Called</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Called<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>property<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span>, object<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span>, desc<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isCalled</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionFunction.tsx#L160">siesta/src/siesta/test/assertion/AssertionFunction.tsx:160</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is a shortcut alias for <a href="browser.TestBrowser.html#isCalledNTimes">isCalledNTimes</a>, with the <code>expected</code> argument hardcoded to the <code>&gt;= 1</code>.
It passes if the function property is called at least one time during the test life span.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">object</span></h4></li><li><h4>K<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">symbol</span></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>property: <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The function itself or the name of the function property on the host object (2nd argument)</p>
</div></div></li><li><h5>object: <span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The host object</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> desc: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The description of the assertion</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="isCalledNTimes" class="tsd-anchor"></a><h3>is<wbr/>CalledNTimes</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>CalledNTimes<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>property<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span>, object<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span>, desc<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span>, isGreaterEqual<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isCalledNTimes</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionFunction.tsx#L134">siesta/src/siesta/test/assertion/AssertionFunction.tsx:134</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the object&#39;s function property is called the expected number of times during the test life span.
The expected number of calls can be either a number or a string, consisting from the comparison operator
and a number. See [[FiresOkOptions.events]] for more details.</p>
</div><div><p>For example:</p>
<pre><code class="language-js"><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">obj</span><span class="hl-0"> = {</span><br/><span class="hl-0">    </span><span class="hl-2">data     :</span><span class="hl-0"> </span><span class="hl-7">1</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-3">increment</span><span class="hl-2"> :</span><span class="hl-0"> </span><span class="hl-6">function</span><span class="hl-0"> () {</span><br/><span class="hl-0">        </span><span class="hl-1">return</span><span class="hl-0"> ++</span><span class="hl-6">this</span><span class="hl-0">.</span><span class="hl-2">data</span><br/><span class="hl-0">    }</span><br/><span class="hl-0">}</span><br/><br/><span class="hl-5">// exact number of calls</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">isCalledNTimes</span><span class="hl-0">(</span><span class="hl-4">&#39;increment&#39;</span><span class="hl-0">, </span><span class="hl-2">obj</span><span class="hl-0">, </span><span class="hl-7">3</span><span class="hl-0">, </span><span class="hl-4">&#39;Correct number of calls to `increment`&#39;</span><span class="hl-0">)</span><br/><br/><span class="hl-5">// expected number of calls as expression</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">isCalledNTimes</span><span class="hl-0">(</span><span class="hl-4">&#39;increment&#39;</span><span class="hl-0">, </span><span class="hl-2">obj</span><span class="hl-0">, </span><span class="hl-4">&#39;&lt;= 3&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;Correct number of calls to `increment`&#39;</span><span class="hl-0">)</span><br/><br/><span class="hl-5">// passing property itself</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">isCalledNTimes</span><span class="hl-0">(</span><span class="hl-2">obj</span><span class="hl-0">.</span><span class="hl-2">increment</span><span class="hl-0">, </span><span class="hl-2">obj</span><span class="hl-0">, </span><span class="hl-7">3</span><span class="hl-0">, </span><span class="hl-4">&#39;Correct number of calls to `increment`&#39;</span><span class="hl-0">)</span>
</code></pre>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">object</span></h4></li><li><h4>K<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">symbol</span></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>property: <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The function itself or the name of the function property on the host object (2nd argument)</p>
</div></div></li><li><h5>object: <span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The host object</p>
</div></div></li><li><h5>expected: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The expected number of calls</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> desc: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The description of the assertion</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> isGreaterEqual: <span class="tsd-signature-type">boolean</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="isCalledOnce" class="tsd-anchor"></a><h3>is<wbr/>Called<wbr/>Once</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Called<wbr/>Once<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>property<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span>, object<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span>, desc<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isCalledOnce</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionFunction.tsx#L175">siesta/src/siesta/test/assertion/AssertionFunction.tsx:175</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is a shortcut alias for <a href="browser.TestBrowser.html#isCalledNTimes">isCalledNTimes</a>, with the <code>expected</code> argument hardcoded to the <code>1</code>.
It passes if the function property is called exactly once time during the test life span.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">object</span></h4></li><li><h4>K<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">symbol</span></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>property: <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The function itself or the name of the function property on the host object (2nd argument)</p>
</div></div></li><li><h5>object: <span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The host object</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> desc: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The description of the assertion</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="isntCalled" class="tsd-anchor"></a><h3>isnt<wbr/>Called</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">isnt<wbr/>Called<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>property<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span>, object<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span>, desc<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isntCalled</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionFunction.tsx#L190">siesta/src/siesta/test/assertion/AssertionFunction.tsx:190</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is a shortcut alias for <a href="browser.TestBrowser.html#isCalledNTimes">isCalledNTimes</a>, with the <code>expected</code> argument hardcoded to the <code>0</code>.
It passes if the function property is not called during the test life span.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">object</span></h4></li><li><h4>K<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">symbol</span></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>property: <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The function itself or the name of the function property on the host object (2nd argument)</p>
</div></div></li><li><h5>object: <span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The host object</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> desc: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The description of the assertion</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="methodIsCalled" class="tsd-anchor"></a><h3>method<wbr/>Is<wbr/>Called</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">method<wbr/>Is<wbr/>Called<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>property<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span>, cls<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span>, desc<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).methodIsCalled</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionFunction.tsx#L271">siesta/src/siesta/test/assertion/AssertionFunction.tsx:271</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is a shortcut alias for <a href="browser.TestBrowser.html#methodIsCalledNTimes">methodIsCalledNTimes</a>, with the <code>expected</code> argument hardcoded to <code>&gt;=1</code>.
It passes if the method is called at least once during the test life span.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyConstructor" class="tsd-signature-type" data-tsd-kind="Type alias">AnyConstructor</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li><h4>K<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">symbol</span></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>property: <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The function itself or the name of the function property on the host object (2nd argument)</p>
</div></div></li><li><h5>cls: <span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> desc: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The description of the assertion</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="methodIsCalledNTimes" class="tsd-anchor"></a><h3>method<wbr/>Is<wbr/>CalledNTimes</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">method<wbr/>Is<wbr/>CalledNTimes<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>property<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span>, cls<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span>, desc<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span>, isGreaterEqual<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).methodIsCalledNTimes</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionFunction.tsx#L245">siesta/src/siesta/test/assertion/AssertionFunction.tsx:245</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes when the supplied class method is called the expected number of times during the test life span.
The expected number of calls can be either a number or a string, consisting from the comparison operator
and a number. See [[FiresOkOptions.events]] for more details.</p>
</div><div><p>Under &quot;class method&quot; here we mean the function in the prototype. Note, that this assertion counts calls to the method in <em>any</em> class instance.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-6">class</span><span class="hl-0"> </span><span class="hl-8">Car</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-6">constructor</span><span class="hl-0"> (</span><span class="hl-2">type</span><span class="hl-0">, </span><span class="hl-2">version</span><span class="hl-0">) {</span><br/><span class="hl-0">        </span><span class="hl-6">this</span><span class="hl-0">.</span><span class="hl-2">carInfo</span><span class="hl-0"> = {</span><br/><span class="hl-0">            </span><span class="hl-2">type        :</span><span class="hl-0"> </span><span class="hl-2">type</span><span class="hl-0">,</span><br/><span class="hl-0">            </span><span class="hl-2">version     :</span><span class="hl-0"> </span><span class="hl-2">version</span><br/><span class="hl-0">        }</span><br/><span class="hl-0">    }</span><br/><br/><span class="hl-0">    </span><span class="hl-3">update</span><span class="hl-0"> (</span><span class="hl-2">type</span><span class="hl-0">, </span><span class="hl-2">version</span><span class="hl-0">) {</span><br/><span class="hl-0">        </span><span class="hl-6">this</span><span class="hl-0">.</span><span class="hl-3">setVersion</span><span class="hl-0">(</span><span class="hl-2">type</span><span class="hl-0">);</span><br/><span class="hl-0">        </span><span class="hl-6">this</span><span class="hl-0">.</span><span class="hl-3">setType</span><span class="hl-0">(</span><span class="hl-2">version</span><span class="hl-0">);</span><br/><span class="hl-0">    }</span><br/><br/><span class="hl-0">    </span><span class="hl-3">setVersion</span><span class="hl-0"> (</span><span class="hl-2">data</span><span class="hl-0">) {</span><br/><span class="hl-0">        </span><span class="hl-6">this</span><span class="hl-0">.</span><span class="hl-2">carInfo</span><span class="hl-0">.</span><span class="hl-2">version</span><span class="hl-0"> = </span><span class="hl-2">data</span><span class="hl-0">;</span><br/><span class="hl-0">    }</span><br/><br/><span class="hl-0">    </span><span class="hl-3">setType</span><span class="hl-0"> (</span><span class="hl-2">data</span><span class="hl-0">) {</span><br/><span class="hl-0">        </span><span class="hl-6">this</span><span class="hl-0">.</span><span class="hl-2">carInfo</span><span class="hl-0">.</span><span class="hl-2">type</span><span class="hl-0"> = </span><span class="hl-2">data</span><span class="hl-0">;</span><br/><span class="hl-0">    }</span><br/><span class="hl-0">};</span><br/><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">methodIsCalled</span><span class="hl-0">(</span><span class="hl-4">&quot;setVersion&quot;</span><span class="hl-0">, </span><span class="hl-2">Car</span><span class="hl-0">, </span><span class="hl-4">&quot;Checking if method &#39;setVersion&#39; has been called&quot;</span><span class="hl-0">);</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">methodIsCalled</span><span class="hl-0">(</span><span class="hl-4">&quot;setType&quot;</span><span class="hl-0">, </span><span class="hl-2">Car</span><span class="hl-0">, </span><span class="hl-4">&quot;Checking if method &#39;setType&#39; has been called&quot;</span><span class="hl-0">);</span><br/><br/><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">m</span><span class="hl-0"> = </span><span class="hl-6">new</span><span class="hl-0"> </span><span class="hl-3">Car</span><span class="hl-0">(</span><span class="hl-4">&#39;rover&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;0.1.2&#39;</span><span class="hl-0">);</span><br/><br/><span class="hl-2">m</span><span class="hl-0">.</span><span class="hl-3">update</span><span class="hl-0">(</span><span class="hl-4">&#39;3.2.1&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;New Rover&#39;</span><span class="hl-0">);</span>
</code></pre>
<p>This assertion is useful when you need to verify the method calls during
class instantiation time, which means you need to observe the prototype method <em>before</em> the instantiation.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyConstructor" class="tsd-signature-type" data-tsd-kind="Type alias">AnyConstructor</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li><h4>K<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">symbol</span></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>property: <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The method function itself or its name</p>
</div></div></li><li><h5>cls: <span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The class</p>
</div></div></li><li><h5>expected: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The expected number of calls.</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> desc: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The description of the assertion</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> isGreaterEqual: <span class="tsd-signature-type">boolean</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="methodIsntCalled" class="tsd-anchor"></a><h3>method<wbr/>Isnt<wbr/>Called</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">method<wbr/>Isnt<wbr/>Called<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>property<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span>, cls<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span>, desc<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).methodIsntCalled</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionFunction.tsx#L287">siesta/src/siesta/test/assertion/AssertionFunction.tsx:287</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is a shortcut alias for <a href="browser.TestBrowser.html#methodIsCalledNTimes">methodIsCalledNTimes</a>, with the <code>expected</code> argument hardcoded to <code>0</code>.
It passes if the method is not called during the test life span.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyConstructor" class="tsd-signature-type" data-tsd-kind="Type alias">AnyConstructor</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li><h4>K<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">symbol</span></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>property: <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">K</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The function itself or the name of the function property on the host object (2nd argument)</p>
</div></div></li><li><h5>cls: <span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> desc: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The description of the assertion</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Fuzzy comparison</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="any" class="tsd-anchor"></a><h3>any</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">any<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">...</span>args<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol"> extends </span><span class="tsd-signature-symbol">[</span><span class="tsd-signature-symbol">]</span><span class="tsd-signature-symbol"> ? </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol"> : </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol"> extends </span><span class="tsd-signature-symbol">[</span><a href="../modules/index._internal_.html#AnyConstructor" class="tsd-signature-type" data-tsd-kind="Type alias">AnyConstructor</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">I</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">]</span><span class="tsd-signature-symbol"> ? </span><span class="tsd-signature-type">DowngradePrimitives</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">I</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> : </span><span class="tsd-signature-type">never</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).any</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L673">siesta/src/siesta/test/assertion/AssertionCompare.tsx:673</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Return a fuzzy matcher instance.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">[</span><span class="tsd-signature-symbol">]</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-symbol">[</span><a href="../modules/index._internal_.html#AnyConstructor" class="tsd-signature-type" data-tsd-kind="Type alias">AnyConstructor</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">]</span></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagRest">Rest</span> <span class="tsd-signature-symbol">...</span>args: <span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol"> extends </span><span class="tsd-signature-symbol">[</span><span class="tsd-signature-symbol">]</span><span class="tsd-signature-symbol"> ? </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol"> : </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol"> extends </span><span class="tsd-signature-symbol">[</span><a href="../modules/index._internal_.html#AnyConstructor" class="tsd-signature-type" data-tsd-kind="Type alias">AnyConstructor</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">I</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">]</span><span class="tsd-signature-symbol"> ? </span><span class="tsd-signature-type">DowngradePrimitives</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">I</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> : </span><span class="tsd-signature-type">never</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="anyNumberApprox" class="tsd-anchor"></a><h3>any<wbr/>Number<wbr/>Approx</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">any<wbr/>Number<wbr/>Approx<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span>, approx<span class="tsd-signature-symbol">?: </span><a href="../modules/index._internal_.html#Approximation" class="tsd-signature-type" data-tsd-kind="Type alias">Approximation</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="index._internal_.FuzzyMatcherNumberApproximation.html" class="tsd-signature-type" data-tsd-kind="Class">FuzzyMatcherNumberApproximation</a></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).anyNumberApprox</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L685">siesta/src/siesta/test/assertion/AssertionCompare.tsx:685</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Returns a fuzzy matcher instance.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">number</span></h5></li><li><h5>approx: <a href="../modules/index._internal_.html#Approximation" class="tsd-signature-type" data-tsd-kind="Type alias">Approximation</a><span class="tsd-signature-symbol"> = ...</span></h5></li></ul><h4 class="tsd-returns-title">Returns <a href="index._internal_.FuzzyMatcherNumberApproximation.html" class="tsd-signature-type" data-tsd-kind="Class">FuzzyMatcherNumberApproximation</a></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="anyStringLike" class="tsd-anchor"></a><h3>any<wbr/>String<wbr/>Like</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">any<wbr/>String<wbr/>Like<span class="tsd-signature-symbol">(</span>pattern<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">RegExp</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="index._internal_.FuzzyMatcherString.html" class="tsd-signature-type" data-tsd-kind="Class">FuzzyMatcherString</a></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).anyStringLike</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L697">siesta/src/siesta/test/assertion/AssertionCompare.tsx:697</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Returns a fuzzy matcher instance.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>pattern: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">RegExp</span></h5></li></ul><h4 class="tsd-returns-title">Returns <a href="index._internal_.FuzzyMatcherString.html" class="tsd-signature-type" data-tsd-kind="Class">FuzzyMatcherString</a></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isApprox" class="tsd-anchor"></a><h3>is<wbr/>Approx</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Approx<span class="tsd-signature-symbol">(</span>received<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span>, approx<span class="tsd-signature-symbol">?: </span><a href="../modules/index._internal_.html#Approximation" class="tsd-signature-type" data-tsd-kind="Type alias">Approximation</a>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isApprox</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L647">siesta/src/siesta/test/assertion/AssertionCompare.tsx:647</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes, if the received value is approximately equal to the expected.
The notion of &quot;approximate equality&quot; is defined with the <code>approx</code> attribute,
which is converted to the <a href="index._internal_.NumberApproximation.html">NumberApproximation</a> with the <a href="index._internal_.NumberApproximation.html#fromApproximation">NumberApproximation.fromApproximation</a>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>received: <span class="tsd-signature-type">number</span></h5></li><li><h5>expected: <span class="tsd-signature-type">number</span></h5></li><li><h5>approx: <a href="../modules/index._internal_.html#Approximation" class="tsd-signature-type" data-tsd-kind="Type alias">Approximation</a><span class="tsd-signature-symbol"> = ...</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Logging</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="debug" class="tsd-anchor"></a><h3>debug</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">debug<span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">...</span>message<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).debug</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/logger/Logger.ts#L78">siesta/src/logger/Logger.ts:78</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>The log method for the <code>debug</code> <a href="../enums/index._internal_.LogLevel.html">log level</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagRest">Rest</span> <span class="tsd-signature-symbol">...</span>message: <span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="error" class="tsd-anchor"></a><h3>error</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">error<span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">...</span>message<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).error</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/logger/Logger.ts#L117">siesta/src/logger/Logger.ts:117</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>The log method for the <code>error</code> <a href="../enums/index._internal_.LogLevel.html">log level</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagRest">Rest</span> <span class="tsd-signature-symbol">...</span>message: <span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="info" class="tsd-anchor"></a><h3>info</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">info<span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">...</span>message<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).info</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/logger/Logger.ts#L67">siesta/src/logger/Logger.ts:67</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>The log method for the <code>info</code> <a href="../enums/index._internal_.LogLevel.html">log level</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagRest">Rest</span> <span class="tsd-signature-symbol">...</span>message: <span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="log" class="tsd-anchor"></a><h3>log</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">log<span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">...</span>message<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).log</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/logger/Logger.ts#L89">siesta/src/logger/Logger.ts:89</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>The log method for the  <code>log</code> <a href="../enums/index._internal_.LogLevel.html">log level</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagRest">Rest</span> <span class="tsd-signature-symbol">...</span>message: <span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="warn" class="tsd-anchor"></a><h3>warn</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">warn<span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">...</span>message<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).warn</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/logger/Logger.ts#L106">siesta/src/logger/Logger.ts:106</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>The log method for the <code>warn</code> <a href="../enums/index._internal_.LogLevel.html">log level</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagRest">Rest</span> <span class="tsd-signature-symbol">...</span>message: <span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Mocking</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="createSpy" class="tsd-anchor"></a><h3>create<wbr/>Spy</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">create<wbr/>Spy<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>spyName<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol"> &amp; </span><span class="tsd-signature-symbol">{}</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).createSpy</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L872">siesta/src/siesta/test/Test.ts:872</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This method create a standalone spy function, which tracks all calls to it. Tracking is done using the associated
spy instance, which is available as <code>and</code> property. One can use the <a href="index._internal_.Spy.html">Spy</a> class API to
verify the calls to the spy function.</p>
</div><div><p>For example:</p>
<pre><code class="language-ts"><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">spyFunc</span><span class="hl-0">     = </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">createSpy</span><span class="hl-0">(</span><span class="hl-4">&#39;onadd listener&#39;</span><span class="hl-0">)</span><br/><br/><span class="hl-2">myObservable</span><span class="hl-0">.</span><span class="hl-3">addEventListener</span><span class="hl-0">(</span><span class="hl-4">&#39;add&#39;</span><span class="hl-0">, </span><span class="hl-2">spyFunc</span><span class="hl-0">)</span><br/><br/><span class="hl-5">// do something that triggers the `add` event on the `myObservable`</span><br/><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">expect</span><span class="hl-0">(</span><span class="hl-2">spyFunc</span><span class="hl-0">).</span><span class="hl-3">toHaveBeenCalled</span><span class="hl-0">()</span><br/><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">expect</span><span class="hl-0">(</span><span class="hl-2">spyFunc</span><span class="hl-0">.</span><span class="hl-2">calls</span><span class="hl-0">.</span><span class="hl-3">argsFor</span><span class="hl-0">(</span><span class="hl-7">1</span><span class="hl-0">)).</span><span class="hl-3">toEqual</span><span class="hl-0">([ </span><span class="hl-4">&#39;Arg1&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;Arg2&#39;</span><span class="hl-0"> ])</span>
</code></pre>
<p>See also: <a href="browser.TestBrowser.html#spyOn">spyOn</a></p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span> = <a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>spyName: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;James Bond&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>A name of the spy for debugging purposes</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol"> &amp; </span><span class="tsd-signature-symbol">{}</span></h4><div><p>Created function. The associated spy instance is assigned to it as the <code>spy</code> property</p>
</div></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="createSpyObj" class="tsd-anchor"></a><h3>create<wbr/>Spy<wbr/>Obj</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">create<wbr/>Spy<wbr/>Obj<span class="tsd-signature-symbol">(</span>properties<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">ArbitraryObjectKey</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">ArbitraryObject</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">SpyFunction</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).createSpyObj</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L908">siesta/src/siesta/test/Test.ts:908</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This method creates an object, which properties are spy functions. Such object can later be used as a mockup.</p>
</div><div><p>This method can be called with one argument only, which should be an array of properties.</p>
<p>For example:</p>
<pre><code class="language-ts"><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">mockup</span><span class="hl-0">      = </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">createSpyObj</span><span class="hl-0">(</span><span class="hl-4">&#39;encoder-mockup&#39;</span><span class="hl-0">, [ </span><span class="hl-4">&#39;encode&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;decode&#39;</span><span class="hl-0"> ])</span><br/><span class="hl-5">// or just</span><br/><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">mockup</span><span class="hl-0">      = </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">createSpyObj</span><span class="hl-0">([ </span><span class="hl-4">&#39;encode&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;decode&#39;</span><span class="hl-0"> ])</span><br/><br/><span class="hl-2">mockup</span><span class="hl-0">.</span><span class="hl-3">encode</span><span class="hl-0">(</span><span class="hl-4">&#39;string&#39;</span><span class="hl-0">)</span><br/><span class="hl-2">mockup</span><span class="hl-0">.</span><span class="hl-3">decode</span><span class="hl-0">(</span><span class="hl-4">&#39;string&#39;</span><span class="hl-0">)</span><br/><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">expect</span><span class="hl-0">(</span><span class="hl-2">mockup</span><span class="hl-0">.</span><span class="hl-2">encode</span><span class="hl-0">).</span><span class="hl-3">toHaveBeenCalled</span><span class="hl-0">()</span>
</code></pre>
<p>See also: <a href="browser.TestBrowser.html#createSpy">createSpy</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>properties: <span class="tsd-signature-type">ArbitraryObjectKey</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>An array of the property names. For each property name a spy function will be created.</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">ArbitraryObject</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">SpyFunction</span><span class="tsd-signature-symbol">&gt;</span></h4><div><p>A mockup object</p>
</div></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="spyOn" class="tsd-anchor"></a><h3>spy<wbr/>On</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">spy<wbr/>On<span class="tsd-signature-symbol">(</span>object<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, propertyName<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">ArbitraryObjectKey</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="index._internal_.Spy.html" class="tsd-signature-type" data-tsd-kind="Class">Spy</a></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).spyOn</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L834">siesta/src/siesta/test/Test.ts:834</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This method installs a &quot;spy&quot; instead of normal function in some object. The &quot;spy&quot; is basically another function,
which tracks its calls. With spies, one can verify that some function has been called and that
it has been called with certain arguments.</p>
</div><div><p>By default, spy will call the original method and return a value from it. To enable different behavior, you can use one of these methods:</p>
<ul>
<li><a href="index._internal_.Spy.html#returnValue">returnValue</a> - return a specific value</li>
<li><a href="index._internal_.Spy.html#callThrough">callThrough</a> - call the original method and return a value from it</li>
<li><a href="index._internal_.Spy.html#stub">stub</a> - call the original method and return a value from it</li>
<li><a href="index._internal_.Spy.html#callFake">callFake</a> - call the provided function and return a value from it</li>
<li><a href="index._internal_.Spy.html#throwError">throwError</a> - throw a specific exception object</li>
</ul>
<p>For example:</p>
<pre><code class="language-ts"><span class="hl-5">// spy that tracks the calls to `process`</span><br/><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">spy</span><span class="hl-0"> = </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">spyOn</span><span class="hl-0">(</span><span class="hl-2">obj</span><span class="hl-0">, </span><span class="hl-4">&#39;process&#39;</span><span class="hl-0">)</span><br/><br/><span class="hl-5">// or, if you need to also mock the method</span><br/><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">spy</span><span class="hl-0"> = </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">spyOn</span><span class="hl-0">(</span><span class="hl-2">obj</span><span class="hl-0">, </span><span class="hl-4">&#39;process&#39;</span><span class="hl-0">).</span><span class="hl-3">callFake</span><span class="hl-0">(() </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-5">// is called instead of `process` method</span><br/><span class="hl-0">})</span><br/><br/><span class="hl-5">// call the method</span><br/><span class="hl-2">obj</span><span class="hl-0">.</span><span class="hl-3">process</span><span class="hl-0">(</span><span class="hl-4">&#39;fast&#39;</span><span class="hl-0">, </span><span class="hl-7">1</span><span class="hl-0">)</span><br/><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">expect</span><span class="hl-0">(</span><span class="hl-2">spy</span><span class="hl-0">).</span><span class="hl-3">toHaveBeenCalled</span><span class="hl-0">();</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">expect</span><span class="hl-0">(</span><span class="hl-2">spy</span><span class="hl-0">).</span><span class="hl-3">toHaveBeenCalledWith</span><span class="hl-0">(</span><span class="hl-4">&#39;fast&#39;</span><span class="hl-0">, </span><span class="hl-7">1</span><span class="hl-0">);</span>
</code></pre>
<p>See also <a href="browser.TestBrowser.html#createSpy">createSpy</a>, <a href="browser.TestBrowser.html#createSpyObj">createSpyObj</a>, <a href="index._internal_.Expectation.html#toHaveBeenCalled">toHaveBeenCalled</a>,
<a href="index._internal_.Expectation.html#toHaveBeenCalledWith">toHaveBeenCalledWith</a></p>
<p>See also the <a href="index._internal_.Spy.html">Spy</a> class for additional details.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>object: <span class="tsd-signature-type">unknown</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>An object which property is being spied</p>
</div></div></li><li><h5>propertyName: <span class="tsd-signature-type">ArbitraryObjectKey</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>A name of the property over which to install the spy.</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <a href="index._internal_.Spy.html" class="tsd-signature-type" data-tsd-kind="Class">Spy</a></h4><div><p>spy Created spy instance</p>
</div></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Numeric comparison</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isGE" class="tsd-anchor"></a><h3>isGE</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">isGE<span class="tsd-signature-symbol">(</span>received<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isGE</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L564">siesta/src/siesta/test/assertion/AssertionCompare.tsx:564</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Alias for <a href="browser.TestBrowser.html#isGreaterOrEqual">isGreaterOrEqual</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>received: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>expected: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isGreater" class="tsd-anchor"></a><h3>is<wbr/>Greater</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Greater<span class="tsd-signature-symbol">(</span>received<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isGreater</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L539">siesta/src/siesta/test/assertion/AssertionCompare.tsx:539</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received value is greater than expected, as defined by the <code>&gt;</code> operator.
It works for numbers, Dates and other values that overloads the <code>valueOf</code> method.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>received: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>expected: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isGreaterOrEqual" class="tsd-anchor"></a><h3>is<wbr/>Greater<wbr/>Or<wbr/>Equal</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Greater<wbr/>Or<wbr/>Equal<span class="tsd-signature-symbol">(</span>received<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isGreaterOrEqual</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L552">siesta/src/siesta/test/assertion/AssertionCompare.tsx:552</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received value is greater or equal than expected, as defined by the <code>&gt;=</code> operator.
It works for numbers, Dates and other values that overloads the <code>valueOf</code> method.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>received: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>expected: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isLE" class="tsd-anchor"></a><h3>isLE</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">isLE<span class="tsd-signature-symbol">(</span>received<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isLE</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L602">siesta/src/siesta/test/assertion/AssertionCompare.tsx:602</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Alias for <a href="browser.TestBrowser.html#isLessOrEqual">isLessOrEqual</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>received: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>expected: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isLess" class="tsd-anchor"></a><h3>is<wbr/>Less</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Less<span class="tsd-signature-symbol">(</span>received<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isLess</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L577">siesta/src/siesta/test/assertion/AssertionCompare.tsx:577</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received value is less than expected, as defined by the <code>&lt;</code> operator.
It works for numbers, Dates and other values that overloads the <code>valueOf</code> method.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>received: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>expected: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isLessOrEqual" class="tsd-anchor"></a><h3>is<wbr/>Less<wbr/>Or<wbr/>Equal</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Less<wbr/>Or<wbr/>Equal<span class="tsd-signature-symbol">(</span>received<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isLessOrEqual</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L590">siesta/src/siesta/test/assertion/AssertionCompare.tsx:590</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received value is less than expected, as defined by the <code>&lt;=</code> operator.
It works for numbers, Dates and other values that overloads the <code>valueOf</code> method.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>received: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>expected: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Observable assertions</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="firesAtLeastNTimes" class="tsd-anchor"></a><h3>fires<wbr/>At<wbr/>LeastNTimes</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">fires<wbr/>At<wbr/>LeastNTimes<span class="tsd-signature-symbol">(</span>observable<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, event<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span>, n<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).firesAtLeastNTimes</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionObservable.tsx#L484">siesta/src/siesta/test/assertion/AssertionObservable.tsx:484</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the provided <code>observable</code> triggers the specified event(s) at least <code>N</code> times times during
the rest of the test execution.</p>
</div><div><p>This method is a specialized form of the <a href="browser.TestBrowser.html#firesOk">firesOk</a> assertion.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>observable: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The observable instance, anything that <a href="browser.TestBrowser.html#resolveObservable">resolveObservable</a> accepts</p>
</div></div></li><li><h5>event: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The name of the event(s)</p>
</div></div></li><li><h5>n: <span class="tsd-signature-type">number</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The minimum number of events to be fired</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>Assertion description</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="firesOk" class="tsd-anchor"></a><h3>fires<wbr/>Ok</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">fires<wbr/>Ok<span class="tsd-signature-symbol">(</span>options<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#FiresOkOptions" class="tsd-signature-type" data-tsd-kind="Type alias">FiresOkOptions</a><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li><li class="tsd-signature tsd-kind-icon">fires<wbr/>Ok<span class="tsd-signature-symbol">(</span>observable<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, events<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li><li class="tsd-signature tsd-kind-icon">fires<wbr/>Ok<span class="tsd-signature-symbol">(</span>observable<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, events<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span>, during<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> | </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li><li class="tsd-signature tsd-kind-icon">fires<wbr/>Ok<span class="tsd-signature-symbol">(</span>observable<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, events<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Record</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">&gt;</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li><li class="tsd-signature tsd-kind-icon">fires<wbr/>Ok<span class="tsd-signature-symbol">(</span>observable<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, events<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Record</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">&gt;</span>, during<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> | </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).firesOk</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionObservable.tsx#L204">siesta/src/siesta/test/assertion/AssertionObservable.tsx:204</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion counts the number of events, triggered by the provided <code>observable</code> instance, during the
provided period and compares it with the expected numbers. The period is specified with the <code>during</code> option and can be:</p>
</div><div><ul>
<li>execution of the provided function (which can possibly be <code>async</code>)</li>
<li>time period, in milliseconds</li>
<li>the rest of the test (if not provided).</li>
</ul>
<p>The exact notion of what the <code>observable</code> is, is defined by the <a href="browser.TestBrowser.html#resolveObservable">resolveObservable</a> method.</p>
<p>This method has several overloads. Normally it accepts a single object with various <a href="../modules/browser._internal_.html#FiresOkOptions">options</a>:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">firesOk</span><span class="hl-0">({</span><br/><span class="hl-0">    </span><span class="hl-2">observable      :</span><span class="hl-0"> </span><span class="hl-2">document</span><span class="hl-0">.</span><span class="hl-2">body</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-2">events          :</span><span class="hl-0"> {</span><br/><span class="hl-0">        </span><span class="hl-2">mousedown        :</span><span class="hl-0"> </span><span class="hl-7">2</span><span class="hl-0">,</span><br/><span class="hl-0">        </span><span class="hl-2">mouseup          :</span><span class="hl-0"> </span><span class="hl-7">2</span><span class="hl-0">,</span><br/><span class="hl-0">        </span><span class="hl-2">click            :</span><span class="hl-0"> </span><span class="hl-4">&#39;&gt; 1&#39;</span><span class="hl-0">,</span><br/><span class="hl-0">        </span><span class="hl-2">dblclick         :</span><span class="hl-0"> </span><span class="hl-4">&#39;== 1&#39;</span><br/><span class="hl-0">    },</span><br/><span class="hl-0">    </span><span class="hl-2">during          :</span><span class="hl-0"> </span><span class="hl-3">async</span><span class="hl-0"> () {</span><br/><span class="hl-0">        await t.click(</span><span class="hl-2">[ </span><span class="hl-7">100</span><span class="hl-2">, </span><span class="hl-7">100</span><span class="hl-2"> ])</span><br/><span class="hl-2">    },</span><br/><span class="hl-2">    desc            :</span><span class="hl-0"> </span><span class="hl-4">&#39;Correct double click events fired&#39;</span><br/><span class="hl-0">})</span>
</code></pre>
<p>This method also can be called in 2 additional shortcuts forms:</p>
<pre><code class="language-javascript"><span class="hl-5">// shortcut form, multiple events</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">firesOk</span><span class="hl-0">(</span><span class="hl-2">observable</span><span class="hl-0">, { </span><span class="hl-2">event1 :</span><span class="hl-0"> </span><span class="hl-7">1</span><span class="hl-0">, </span><span class="hl-2">event2 :</span><span class="hl-0"> </span><span class="hl-4">&#39;&gt;1&#39;</span><span class="hl-0"> }, </span><span class="hl-2">description</span><span class="hl-0">)</span><br/><br/><span class="hl-5">// shortcut form, single event</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">firesOk</span><span class="hl-0">(</span><span class="hl-2">observable</span><span class="hl-0">, </span><span class="hl-2">eventName</span><span class="hl-0">, </span><span class="hl-7">1</span><span class="hl-0">, </span><span class="hl-2">during</span><span class="hl-0">?, </span><span class="hl-2">description</span><span class="hl-0">)</span><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">firesOk</span><span class="hl-0">(</span><span class="hl-2">observable</span><span class="hl-0">, </span><span class="hl-2">eventName</span><span class="hl-0">, </span><span class="hl-4">&#39;&gt;1&#39;</span><span class="hl-0">, </span><span class="hl-2">during</span><span class="hl-0">?, </span><span class="hl-2">description</span><span class="hl-0">)</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>options: <a href="../modules/browser._internal_.html#FiresOkOptions" class="tsd-signature-type" data-tsd-kind="Type alias">FiresOkOptions</a><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).firesOk</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionObservable.tsx#L205">siesta/src/siesta/test/assertion/AssertionObservable.tsx:205</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>observable: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>events: <span class="tsd-signature-type">string</span></h5></li><li><h5>expected: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).firesOk</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionObservable.tsx#L211">siesta/src/siesta/test/assertion/AssertionObservable.tsx:211</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>observable: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>events: <span class="tsd-signature-type">string</span></h5></li><li><h5>expected: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span></h5></li><li><h5>during: <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> | </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).firesOk</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionObservable.tsx#L218">siesta/src/siesta/test/assertion/AssertionObservable.tsx:218</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>observable: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>events: <span class="tsd-signature-type">Record</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).firesOk</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionObservable.tsx#L223">siesta/src/siesta/test/assertion/AssertionObservable.tsx:223</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>observable: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>events: <span class="tsd-signature-type">Record</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>during: <span class="tsd-signature-type">number</span><span class="tsd-signature-symbol"> | </span><a href="../modules/index._internal_.html#AnyFunction" class="tsd-signature-type" data-tsd-kind="Type alias">AnyFunction</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="firesOnce" class="tsd-anchor"></a><h3>fires<wbr/>Once</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">fires<wbr/>Once<span class="tsd-signature-symbol">(</span>observable<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, event<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).firesOnce</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionObservable.tsx#L449">siesta/src/siesta/test/assertion/AssertionObservable.tsx:449</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the provided <code>observable</code> triggers the specified event(s) exactly 1 time during
the rest of the test execution.</p>
</div><div><p>This method is a specialized form of the <a href="browser.TestBrowser.html#firesOk">firesOk</a> assertion.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>observable: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The observable instance, anything that <a href="browser.TestBrowser.html#resolveObservable">resolveObservable</a> accepts</p>
</div></div></li><li><h5>event: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The name of the event(s)</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>Assertion description</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isntFired" class="tsd-anchor"></a><h3>isnt<wbr/>Fired</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">isnt<wbr/>Fired<span class="tsd-signature-symbol">(</span>observable<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, event<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isntFired</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionObservable.tsx#L467">siesta/src/siesta/test/assertion/AssertionObservable.tsx:467</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Alias for <a href="browser.TestBrowser.html#wontFire">wontFire</a> method</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>observable: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>event: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="waitForEvent" class="tsd-anchor"></a><h3>wait<wbr/>For<wbr/>Event</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">wait<wbr/>For<wbr/>Event<span class="tsd-signature-symbol">(</span>observable<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, event<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, options<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/index._internal_.html#WaitForOptions" class="tsd-signature-type" data-tsd-kind="Type alias">WaitForOptions</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).waitForEvent</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionObservable.tsx#L104">siesta/src/siesta/test/assertion/AssertionObservable.tsx:104</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes, if the provided <code>observable</code>, triggers the specified <code>event</code>
within the <code>timeout</code> and fails otherwise. The <code>timeout</code> can be specified using the <code>object</code> argument,
if not provided the <a href="index._internal_.TestDescriptor.html#waitForTimeout">TestDescriptor.waitForTimeout</a> is used.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>observable: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>event: <span class="tsd-signature-type">string</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/index._internal_.html#WaitForOptions" class="tsd-signature-type" data-tsd-kind="Type alias">WaitForOptions</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">unknown</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">void</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="willFireNTimes" class="tsd-anchor"></a><h3>will<wbr/>FireNTimes</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">will<wbr/>FireNTimes<span class="tsd-signature-symbol">(</span>observable<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, event<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span>, expected<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).willFireNTimes</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionObservable.tsx#L401">siesta/src/siesta/test/assertion/AssertionObservable.tsx:401</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the provided <code>observable</code> triggers the specified event(s) exactly <code>N</code> times during
the rest of the test execution.</p>
</div><div><p>This method is a specialized form of the <a href="browser.TestBrowser.html#firesOk">firesOk</a> assertion.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>observable: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The observable instance, anything that <a href="browser.TestBrowser.html#resolveObservable">resolveObservable</a> accepts</p>
</div></div></li><li><h5>event: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The name of the event(s)</p>
</div></div></li><li><h5>expected: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">number</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>Expected number of events</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>Assertion description</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="wontFire" class="tsd-anchor"></a><h3>wont<wbr/>Fire</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">wont<wbr/>Fire<span class="tsd-signature-symbol">(</span>observable<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, event<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).wontFire</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionObservable.tsx#L428">siesta/src/siesta/test/assertion/AssertionObservable.tsx:428</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the provided <code>observable</code> does not trigger the specified event(s) during
the rest of the test execution.</p>
</div><div><p>This method is a specialized form of the <a href="browser.TestBrowser.html#firesOk">firesOk</a> assertion.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>observable: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The observable instance, anything that <a href="browser.TestBrowser.html#resolveObservable">resolveObservable</a> accepts</p>
</div></div></li><li><h5>event: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The name of the event(s)</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> description: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>Assertion description</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Other</h2><section class="tsd-panel tsd-member tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><a id="constructor" class="tsd-anchor"></a><h3>constructor</h3><ul class="tsd-signatures tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">new <wbr/>Test<wbr/>Browser<span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">...</span>input<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).constructor</p><ul><li>Defined in typescript-mixin-class/src/class/Mixin.d.ts:22</li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagRest">Rest</span> <span class="tsd-signature-symbol">...</span>input: <span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">[]</span></h5></li></ul><h4 class="tsd-returns-title">Returns <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><a id="logLevel" class="tsd-anchor"></a><h3>log<wbr/>Level</h3><div class="tsd-signature tsd-kind-icon">log<wbr/>Level<span class="tsd-signature-symbol">:</span> <a href="../enums/index._internal_.LogLevel.html" class="tsd-signature-type" data-tsd-kind="Enumeration">LogLevel</a><span class="tsd-signature-symbol"> = LogLevel.log</span></div><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).logLevel</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/logger/Logger.ts#L53">siesta/src/logger/Logger.ts:53</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>The current log level, the logger operates at.</p>
</div></div></section><section class="tsd-panel tsd-member tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><a id="testDescriptorClass" class="tsd-anchor"></a><h3>test<wbr/>Descriptor<wbr/>Class</h3><div class="tsd-signature tsd-kind-icon">test<wbr/>Descriptor<wbr/>Class<span class="tsd-signature-symbol">:</span> <span class="tsd-signature-symbol">typeof </span><a href="browser._internal_.TestDescriptorBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestDescriptorBrowser</a></div><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).testDescriptorClass</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/TestBrowser.tsx#L53">siesta/src/siesta/test/TestBrowser.tsx:53</a></li></ul></aside></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="contain" class="tsd-anchor"></a><h3>contain</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">contain<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>iterable<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Iterable</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span>, element<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).contain</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L484">siesta/src/siesta/test/assertion/AssertionCompare.tsx:484</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the provided <code>iterable</code> contains the <code>element</code> value.
The element comparison is performed deeply.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>iterable: <span class="tsd-signature-type">Iterable</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>element: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="initialize" class="tsd-anchor"></a><h3>initialize</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">initialize<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>props<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).initialize</p><ul><li>Defined in typescript-mixin-class/src/class/Base.d.ts:13</li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This method applies its 1st argument (if any) to the current instance using <code>Object.assign()</code>.</p>
</div><div><p>Supposed to be overridden in the subclasses to customize the instance creation process.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><a href="index._internal_.Base.html" class="tsd-signature-type" data-tsd-kind="Class">Base</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> props: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a id="notContain" class="tsd-anchor"></a><h3>not<wbr/>Contain</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">not<wbr/>Contain<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>iterable<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Iterable</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span>, element<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).notContain</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L497">siesta/src/siesta/test/assertion/AssertionCompare.tsx:497</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the provided <code>iterable</code> does not contain the <code>element</code> value.
The element comparison is performed deeply.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>V</h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>iterable: <span class="tsd-signature-type">Iterable</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>element: <span class="tsd-signature-type" data-tsd-kind="Type parameter">V</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="resolveObservable" class="tsd-anchor"></a><h3>resolve<wbr/>Observable</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">resolve<wbr/>Observable<span class="tsd-signature-symbol">(</span>source<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).resolveObservable</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/TestBrowser.tsx#L77">siesta/src/siesta/test/TestBrowser.tsx:77</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>source: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">unknown</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a id="maybeNew" class="tsd-anchor"></a><h3><span class="tsd-flag ts-flagStatic">Static</span> maybe<wbr/>New</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><li class="tsd-signature tsd-kind-icon">maybe<wbr/>New<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>props<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).maybeNew</p><ul><li>Defined in typescript-mixin-class/src/class/Base.d.ts:46</li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is a type-safe static constructor method, accepting a single argument. If that argument is already an instance
of this class - it is returned right away, otherwise the <a href="browser.TestBrowser.html#new">new</a> constructor is used for instantiation.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">typeof </span><a href="index._internal_.Base.html" class="tsd-signature-type" data-tsd-kind="Class">Base</a></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> props: <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a id="new" class="tsd-anchor"></a><h3><span class="tsd-flag ts-flagStatic">Static</span> new</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><li class="tsd-signature tsd-kind-icon">new<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>props<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).new</p><ul><li>Defined in typescript-mixin-class/src/class/Base.d.ts:40</li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is a type-safe static constructor method, accepting a single argument, with the object, corresponding to the
class properties. It will generate a compilation error, if unknown property is provided.</p>
</div><div><p>For example:</p>
<pre><code class="language-ts"><span class="hl-6">class</span><span class="hl-0"> </span><span class="hl-8">MyClass</span><span class="hl-0"> </span><span class="hl-6">extends</span><span class="hl-0"> </span><span class="hl-8">Base</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-2">prop</span><span class="hl-0">     : </span><span class="hl-8">string</span><br/><span class="hl-0">}</span><br/><br/><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-9">instance</span><span class="hl-0"> : </span><span class="hl-8">MyClass</span><span class="hl-0"> = </span><span class="hl-2">MyClass</span><span class="hl-0">.</span><span class="hl-3">new</span><span class="hl-0">({ </span><span class="hl-2">prop :</span><span class="hl-0"> </span><span class="hl-4">&#39;prop&#39;</span><span class="hl-0">, </span><span class="hl-2">wrong :</span><span class="hl-0"> </span><span class="hl-7">11</span><span class="hl-0"> })</span>
</code></pre>
<p>will produce:</p>
<pre><code><span class="hl-10">TS2345</span><span class="hl-0">: </span><span class="hl-2">Argument</span><span class="hl-0"> </span><span class="hl-6">of</span><span class="hl-0"> </span><span class="hl-2">type</span><span class="hl-0"> </span><span class="hl-4">&#39;{ prop: string; wrong: number; }&#39;</span><span class="hl-0"> </span><span class="hl-2">is</span><span class="hl-0"> </span><span class="hl-2">not</span><span class="hl-0"> </span><span class="hl-2">assignable</span><span class="hl-0"> </span><span class="hl-2">to</span><span class="hl-0"> </span><span class="hl-2">parameter</span><span class="hl-0"> </span><span class="hl-6">of</span><span class="hl-0"> </span><span class="hl-2">type</span><span class="hl-0"> </span><span class="hl-4">&#39;Partial&lt;MyClass&gt;&#39;</span><span class="hl-0">.</span><br/><span class="hl-8">Object</span><span class="hl-0"> </span><span class="hl-2">literal</span><span class="hl-0"> </span><span class="hl-2">may</span><span class="hl-0"> </span><span class="hl-2">only</span><span class="hl-0"> </span><span class="hl-2">specify</span><span class="hl-0"> </span><span class="hl-2">known</span><span class="hl-0"> </span><span class="hl-2">properties</span><span class="hl-0">, </span><span class="hl-2">and</span><span class="hl-0"> </span><span class="hl-4">&#39;wrong&#39;</span><span class="hl-0"> </span><span class="hl-2">does</span><span class="hl-0"> </span><span class="hl-2">not</span><span class="hl-0"> </span><span class="hl-2">exist</span><span class="hl-0"> </span><span class="hl-6">in</span><span class="hl-0"> </span><span class="hl-2">type</span><span class="hl-0"> </span><span class="hl-4">&#39;Partial&lt;MyClass&gt;&#39;</span>
</code></pre>
<p>The only thing this constructor does is create an instance and call the <a href="browser.TestBrowser.html#initialize">initialize</a> method on it, forwarding
the first argument. The customization of instance is supposed to be performed in that method.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">typeof </span><a href="index._internal_.Base.html" class="tsd-signature-type" data-tsd-kind="Class">Base</a></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> props: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>String pattern matching</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="match" class="tsd-anchor"></a><h3>match</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">match<span class="tsd-signature-symbol">(</span>string<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, pattern<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">RegExp</span>, desc<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).match</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L343">siesta/src/siesta/test/assertion/AssertionCompare.tsx:343</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes when provided <code>string</code> matches the given <code>pattern</code>.</p>
</div><div><p>The <code>pattern</code> can be a <code>RegExp</code> instance or <code>string</code>, in the latter case the provided <code>string</code>
should contain the <code>pattern</code> as a substring.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>string: <span class="tsd-signature-type">string</span></h5></li><li><h5>pattern: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">RegExp</span></h5></li><li><h5>desc: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="notMatch" class="tsd-anchor"></a><h3>not<wbr/>Match</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">not<wbr/>Match<span class="tsd-signature-symbol">(</span>string<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, pattern<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">RegExp</span>, desc<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).notMatch</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionCompare.tsx#L359">siesta/src/siesta/test/assertion/AssertionCompare.tsx:359</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes when provided <code>string</code> does not matches the given <code>pattern</code>.</p>
</div><div><p>The <code>pattern</code> can be a <code>RegExp</code> instance or <code>string</code>, in the latter case the provided <code>string</code>
should not contain the <code>pattern</code> as a substring.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>string: <span class="tsd-signature-type">string</span></h5></li><li><h5>pattern: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">RegExp</span></h5></li><li><h5>desc: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Subtest management</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="afterEach" class="tsd-anchor"></a><h3>after<wbr/>Each</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">after<wbr/>Each<span class="tsd-signature-symbol">(</span>code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).afterEach</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L292">siesta/src/siesta/test/Test.ts:292</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This method allows you to execute some &quot;cleanup&quot; code hook after every &quot;it&quot; section of the current test.
It is usually used to clear some global resource, used by the tests. Sometimes it is actually more convenient,
instead of clearing the resource in the <code>afterEach</code> do that in the <code>beforeEach</code>, after checking that resource
has been allocated. In this way, if you&#39;ll be debugging some individual test section, the resource will still be
available after the test completion.</p>
</div><div><p><code>it</code> sections can be nested, and hooks can be added at every level.
<code>afterEach</code> hooks are executed starting from the inner-most one level.</p>
<p>The 1st argument of the hook function is always the test instance being launched.</p>
<p>If the hook function is <code>async</code> Siesta will <code>await</code> until it completes.</p>
<p>This method can be called several times, providing several hook functions to execute.</p>
<pre><code class="language-javascript"><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">it</span><span class="hl-0">, </span><span class="hl-2">beforeEach</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;@bryntum/siesta/index.js&quot;</span><br/><br/><span class="hl-6">let</span><span class="hl-0"> </span><span class="hl-2">file</span><br/><span class="hl-3">beforeEach</span><span class="hl-0">(() </span><span class="hl-6">=&gt;</span><span class="hl-0"> </span><span class="hl-2">file</span><span class="hl-0"> = </span><span class="hl-3">OPEN_FILE</span><span class="hl-0">())</span><br/><span class="hl-3">afterEach</span><span class="hl-0">(() </span><span class="hl-6">=&gt;</span><span class="hl-0"> </span><span class="hl-3">CLOSE_FILE</span><span class="hl-0">(</span><span class="hl-2">file</span><span class="hl-0">))</span><br/><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Test section #1&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-2">sum</span><span class="hl-0">++</span><br/><span class="hl-0">    </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">equal</span><span class="hl-0">(</span><span class="hl-2">sum</span><span class="hl-0">, </span><span class="hl-7">1</span><span class="hl-0">)</span><br/><span class="hl-0">})</span><br/><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Test section #2&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-2">sum</span><span class="hl-0">++</span><br/><span class="hl-0">    </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">equal</span><span class="hl-0">(</span><span class="hl-2">sum</span><span class="hl-0">, </span><span class="hl-7">1</span><span class="hl-0">)</span><br/><span class="hl-0">})</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="beforeEach" class="tsd-anchor"></a><h3>before<wbr/>Each</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">before<wbr/>Each<span class="tsd-signature-symbol">(</span>code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).beforeEach</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L250">siesta/src/siesta/test/Test.ts:250</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This method allows you to execute some &quot;setup&quot; code hook before every &quot;it&quot; section of the current test.
It is usually used to restore some global state to the predefined value.</p>
</div><div><p><code>it</code> sections can be nested, and hooks can be added at every level.
<code>beforeEach</code> hooks are executed starting from the outer-most one level.</p>
<p>The 1st argument of the hook function is always the test instance being launched.</p>
<p>If the hook function is <code>async</code> Siesta will <code>await</code> until it completes.</p>
<p>This method can be called several times, providing several hook functions to execute.</p>
<pre><code class="language-javascript"><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">it</span><span class="hl-0">, </span><span class="hl-2">beforeEach</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;@bryntum/siesta/index.js&quot;</span><br/><br/><span class="hl-6">let</span><span class="hl-0"> </span><span class="hl-2">sum</span><br/><br/><span class="hl-3">beforeEach</span><span class="hl-0">(() </span><span class="hl-6">=&gt;</span><span class="hl-0"> </span><span class="hl-2">sum</span><span class="hl-0"> = </span><span class="hl-7">0</span><span class="hl-0">)</span><br/><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Test section #1&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-2">sum</span><span class="hl-0">++</span><br/><span class="hl-0">    </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">equal</span><span class="hl-0">(</span><span class="hl-2">sum</span><span class="hl-0">, </span><span class="hl-7">1</span><span class="hl-0">)</span><br/><span class="hl-0">})</span><br/><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Test section #2&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-2">sum</span><span class="hl-0">++</span><br/><span class="hl-0">    </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">equal</span><span class="hl-0">(</span><span class="hl-2">sum</span><span class="hl-0">, </span><span class="hl-7">1</span><span class="hl-0">)</span><br/><span class="hl-0">})</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="ddescribe" class="tsd-anchor"></a><h3>ddescribe</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">ddescribe<span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).ddescribe</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L564">siesta/src/siesta/test/Test.ts:564</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>An alias for <a href="browser.TestBrowser.html#iit">iit</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="describe" class="tsd-anchor"></a><h3>describe</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">describe<span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).describe</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L555">siesta/src/siesta/test/Test.ts:555</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>An alias for <a href="browser.TestBrowser.html#it">it</a></p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="iit" class="tsd-anchor"></a><h3>iit</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">iit<span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).iit</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L463">siesta/src/siesta/test/Test.ts:463</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is an &quot;exclusive&quot; version of the regular <a href="browser.TestBrowser.html#it">it</a> test section. When such exclusive section is found,
the other regular test sections at the same level will not be executed, only &quot;exclusive&quot; ones.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="it" class="tsd-anchor"></a><h3>it</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">it<span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).it</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L519">siesta/src/siesta/test/Test.ts:519</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This method creates a &quot;parent&quot; node in the test file, grouping assertions together. Such node is called &quot;test section&quot; or &quot;sub-test&quot;.
Sub-tests can be nested arbitrarily.</p>
</div><div><p>The 1st argument for this method can be either a string or a configuration object for this test&#39;s <a href="index._internal_.TestDescriptor.html">descriptor</a>.
The string value corresponds to <code>{ title : &#39;string_value&#39; }</code>.</p>
<p>The configuration object of the nested test section &quot;extends&quot; the configuration object of the parent section.</p>
<p>For example if parent section sets the <a href="index._internal_.TestDescriptor.html#defaultTimeout">defaultTimeout</a> to a certain value, the nested section
will use that value too.</p>
<pre><code class="language-javascript"><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">it</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;@bryntum/siesta/index.js&quot;</span><br/><br/><span class="hl-3">it</span><span class="hl-0">({ </span><span class="hl-2">title :</span><span class="hl-0"> </span><span class="hl-4">&#39;Test section&#39;</span><span class="hl-0">, </span><span class="hl-2">defaultTimeout :</span><span class="hl-0"> </span><span class="hl-7">1000</span><span class="hl-0"> }, </span><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Nested test section&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0"> </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">        </span><span class="hl-5">// will fail within 1s</span><br/><span class="hl-0">        </span><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">waitFor</span><span class="hl-0">(() </span><span class="hl-6">=&gt;</span><span class="hl-0"> </span><span class="hl-6">false</span><span class="hl-0">)</span><br/><span class="hl-0">    })</span><br/><span class="hl-0">})</span>
</code></pre>
<p>See also <a href="browser.TestBrowser.html#iit">iit</a>, <a href="browser.TestBrowser.html#xit">xit</a> methods to quickly isolate/exclude a test section.</p>
<p>To create a top-level test section, the <a href="index.Test.html#it-1">it</a> function or <a href="#it-1">it</a> static
method should be used. These aliases can actually be used inside the test function as well, however
it is recommended to use the method on the test instance.</p>
<pre><code class="language-ts"><span class="hl-1">import</span><span class="hl-0"> { </span><span class="hl-2">it</span><span class="hl-0">, </span><span class="hl-2">Test</span><span class="hl-0"> } </span><span class="hl-1">from</span><span class="hl-0"> </span><span class="hl-4">&quot;@bryntum/siesta/index.js&quot;</span><br/><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Test section&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> (</span><span class="hl-2">t</span><span class="hl-0"> : </span><span class="hl-8">Test</span><span class="hl-0">) </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">it</span><span class="hl-0">({ </span><span class="hl-2">title :</span><span class="hl-0"> </span><span class="hl-4">&#39;Nested section&#39;</span><span class="hl-0">, </span><span class="hl-2">isTodo :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> }, </span><span class="hl-6">async</span><span class="hl-0"> (</span><span class="hl-2">t</span><span class="hl-0"> : </span><span class="hl-8">Test</span><span class="hl-0">) </span><span class="hl-6">=&gt;</span><span class="hl-0"> {</span><br/><span class="hl-0">        ...</span><br/><span class="hl-0">    })</span><br/><span class="hl-0">})</span><br/><br/><span class="hl-5">// The following two lines are identical</span><br/><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Test section&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> (</span><span class="hl-2">t</span><span class="hl-0"> : </span><span class="hl-8">Test</span><span class="hl-0">) </span><span class="hl-6">=&gt;</span><span class="hl-0"> { ... }) </span><span class="hl-5">// `it` function</span><br/><span class="hl-2">Test</span><span class="hl-0">.</span><span class="hl-3">it</span><span class="hl-0">(</span><span class="hl-4">&#39;Test section&#39;</span><span class="hl-0">, </span><span class="hl-6">async</span><span class="hl-0"> (</span><span class="hl-2">t</span><span class="hl-0"> : </span><span class="hl-8">Test</span><span class="hl-0">) </span><span class="hl-6">=&gt;</span><span class="hl-0"> { ... }) </span><span class="hl-5">// static `Test.it` method</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The configuration descriptor for the test section</p>
</div></div></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The test function. Can be <code>async</code> if needed or return <code>Promise</code>.</p>
</div></div><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="todo" class="tsd-anchor"></a><h3>todo</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">todo<span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).todo</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L434">siesta/src/siesta/test/Test.ts:434</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This method has the same functionality as <a href="browser.TestBrowser.html#it">it</a>, plus it sets the <a href="index._internal_.TestDescriptor.html#isTodo">isTodo</a> config of the test descriptor to <code>true</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="xit" class="tsd-anchor"></a><h3>xit</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">xit<span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).xit</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L448">siesta/src/siesta/test/Test.ts:448</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This is a no-op method, allowing you to quickly ignore some test sections - just add <code>x</code> (&quot;exclude&quot;) to the section call.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <a href="browser.TestBrowser.html" class="tsd-signature-type" data-tsd-kind="Class">TestBrowser</a></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a id="ddescribe-1" class="tsd-anchor"></a><h3><span class="tsd-flag ts-flagStatic">Static</span> ddescribe</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><li class="tsd-signature tsd-kind-icon">ddescribe<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).ddescribe</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L1001">siesta/src/siesta/test/Test.ts:1001</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Alias for <a href="index.Test.html#iit-1">Test.iit</a>.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">typeof </span><a href="index.Test.html" class="tsd-signature-type" data-tsd-kind="Class">Test</a></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a id="describe-1" class="tsd-anchor"></a><h3><span class="tsd-flag ts-flagStatic">Static</span> describe</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><li class="tsd-signature tsd-kind-icon">describe<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).describe</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L991">siesta/src/siesta/test/Test.ts:991</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Alias for <a href="index.Test.html#it-1">Test.it</a>.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">typeof </span><a href="index.Test.html" class="tsd-signature-type" data-tsd-kind="Class">Test</a></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a id="iit-1" class="tsd-anchor"></a><h3><span class="tsd-flag ts-flagStatic">Static</span> iit</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><li class="tsd-signature tsd-kind-icon">iit<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).iit</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L926">siesta/src/siesta/test/Test.ts:926</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Alias for <a href="index.Test.html#iit-1">Test.iit</a>. Should be used for top-level sub-tests only.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">typeof </span><a href="index.Test.html" class="tsd-signature-type" data-tsd-kind="Class">Test</a></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a id="it-1" class="tsd-anchor"></a><h3><span class="tsd-flag ts-flagStatic">Static</span> it</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><li class="tsd-signature tsd-kind-icon">it<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).it</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L955">siesta/src/siesta/test/Test.ts:955</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Static alias for <a href="index.Test.html#it-1">Test.it</a>. Should be used for top-level sub-tests only. Can be useful if you create your own subclass of the test class.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">typeof </span><a href="index.Test.html" class="tsd-signature-type" data-tsd-kind="Class">Test</a></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a id="xdescribe" class="tsd-anchor"></a><h3><span class="tsd-flag ts-flagStatic">Static</span> xdescribe</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><li class="tsd-signature tsd-kind-icon">xdescribe<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).xdescribe</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L1011">siesta/src/siesta/test/Test.ts:1011</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Alias for <a href="index.Test.html#xit-1">Test.xit</a>.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">typeof </span><a href="index.Test.html" class="tsd-signature-type" data-tsd-kind="Class">Test</a></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a id="xit-1" class="tsd-anchor"></a><h3><span class="tsd-flag ts-flagStatic">Static</span> xit</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><li class="tsd-signature tsd-kind-icon">xit<span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">(</span>name<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span>, code<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).xit</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/Test.ts#L943">siesta/src/siesta/test/Test.ts:943</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Alias for <a href="index.Test.html#xit-1">Test.xit</a>. Should be used for top-level sub-tests only.</p>
</div></div><h4 class="tsd-type-parameters-title">Type parameters</h4><ul class="tsd-type-parameters"><li><h4>T<span class="tsd-signature-symbol">: </span><span class="tsd-signature-symbol">typeof </span><a href="index.Test.html" class="tsd-signature-type" data-tsd-kind="Class">Test</a></h4></li></ul><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>name: <a href="../modules/index._internal_.html#TestDescriptorArgument" class="tsd-signature-type" data-tsd-kind="Type alias">TestDescriptorArgument</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">&gt;</span></h5></li><li><h5>code: <span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">any</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div><ul class="tsd-parameters"><li class="tsd-parameter-signature"><ul class="tsd-signatures tsd-kind-type-literal"><li class="tsd-signature tsd-kind-icon"><span class="tsd-signature-symbol">(</span>t<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>t: <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></li></ul></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">InstanceType</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type" data-tsd-kind="Type parameter">T</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>Typeguards</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isArray" class="tsd-anchor"></a><h3>is<wbr/>Array</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Array<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isArray</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L146">siesta/src/siesta/test/assertion/AssertionType.tsx:146</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>Array</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isBoolean" class="tsd-anchor"></a><h3>is<wbr/>Boolean</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Boolean<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isBoolean</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L106">siesta/src/siesta/test/assertion/AssertionType.tsx:106</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>Boolean</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isDate" class="tsd-anchor"></a><h3>is<wbr/>Date</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Date<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isDate</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L156">siesta/src/siesta/test/assertion/AssertionType.tsx:156</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>Date</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isFunction" class="tsd-anchor"></a><h3>is<wbr/>Function</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Function<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isFunction</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L176">siesta/src/siesta/test/assertion/AssertionType.tsx:176</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>Function</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isInstanceOf" class="tsd-anchor"></a><h3>is<wbr/>Instance<wbr/>Of</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Instance<wbr/>Of<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, cls<span class="tsd-signature-symbol">: </span><a href="../modules/index._internal_.html#AnyConstructor" class="tsd-signature-type" data-tsd-kind="Type alias">AnyConstructor</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">&gt;</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isInstanceOf</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L84">siesta/src/siesta/test/assertion/AssertionType.tsx:84</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is an instance of the <code>cls</code> class. It works for native built-in classes
too.</p>
</div><div><p>For example:</p>
<pre><code class="language-ts"><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">isInstanceOf</span><span class="hl-0">([ </span><span class="hl-7">1</span><span class="hl-0">, </span><span class="hl-7">2</span><span class="hl-0">, </span><span class="hl-7">3</span><span class="hl-0"> ], </span><span class="hl-8">Array</span><span class="hl-0">)</span><br/><br/><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">isInstanceOf</span><span class="hl-0">(</span><span class="hl-7">1</span><span class="hl-0">, </span><span class="hl-8">Number</span><span class="hl-0">)</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The received value</p>
</div></div></li><li><h5>cls: <a href="../modules/index._internal_.html#AnyConstructor" class="tsd-signature-type" data-tsd-kind="Type alias">AnyConstructor</a><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">, </span><span class="tsd-signature-type">object</span><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The class constructor</p>
</div></div></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isMap" class="tsd-anchor"></a><h3>is<wbr/>Map</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Map<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isMap</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L196">siesta/src/siesta/test/assertion/AssertionType.tsx:196</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>Map</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isNumber" class="tsd-anchor"></a><h3>is<wbr/>Number</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Number<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isNumber</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L126">siesta/src/siesta/test/assertion/AssertionType.tsx:126</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>Number</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isObject" class="tsd-anchor"></a><h3>is<wbr/>Object</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Object<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isObject</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L136">siesta/src/siesta/test/assertion/AssertionType.tsx:136</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>Object</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isRegExp" class="tsd-anchor"></a><h3>is<wbr/>Reg<wbr/>Exp</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Reg<wbr/>Exp<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isRegExp</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L166">siesta/src/siesta/test/assertion/AssertionType.tsx:166</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>RegExp</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isSet" class="tsd-anchor"></a><h3>is<wbr/>Set</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Set<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isSet</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L186">siesta/src/siesta/test/assertion/AssertionType.tsx:186</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>Set</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isString" class="tsd-anchor"></a><h3>is<wbr/>String</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>String<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isString</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L116">siesta/src/siesta/test/assertion/AssertionType.tsx:116</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>String</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isWeakMap" class="tsd-anchor"></a><h3>is<wbr/>Weak<wbr/>Map</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Weak<wbr/>Map<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isWeakMap</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L216">siesta/src/siesta/test/assertion/AssertionType.tsx:216</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>WeakMap</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="isWeakSet" class="tsd-anchor"></a><h3>is<wbr/>Weak<wbr/>Set</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">is<wbr/>Weak<wbr/>Set<span class="tsd-signature-symbol">(</span>value<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">unknown</span>, description<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">void</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).isWeakSet</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/test/assertion/AssertionType.tsx#L206">siesta/src/siesta/test/assertion/AssertionType.tsx:206</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>This assertion passes if the received <code>value</code> is a <code>WeakSet</code>.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>value: <span class="tsd-signature-type">unknown</span></h5></li><li><h5>description: <span class="tsd-signature-type">string</span><span class="tsd-signature-symbol"> = &#39;&#39;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">void</span></h4></li></ul></section></section><section class="tsd-panel-group tsd-member-group tsd-kind-class tsd-parent-kind-module"><h2>User action simulation</h2><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="click" class="tsd-anchor"></a><h3>click</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">click<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, offset<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li><li class="tsd-signature tsd-kind-icon">click<span class="tsd-signature-symbol">(</span>options<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).click</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L988">siesta/src/siesta/simulate/UserAgent.tsx:988</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates a click on the given <a href="../modules/browser._internal_.html#ActionTarget">ActionTarget</a> at the given <a href="../modules/browser._internal_.html#ActionTargetOffset">ActionTargetOffset</a> point. If offset is not provided
the action happens in the center of the visible part of the target element.</p>
</div><div><p>Before performing an action, Siesta waits for the target element to <a href="../modules/Guide__Auto_waiting.html#AutoWaitingGuide">become actionable</a>
and synchronize the cursor position.</p>
<p>This method has 2 overloads and <code>target</code> and <code>offset</code> can be given either as positional arguments, or in the form
of the <a href="../modules/browser._internal_.html#MouseActionOptions">MouseActionOptions</a> object.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">click</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ])</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">click</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, { </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">click</span><span class="hl-0">({ </span><span class="hl-2">target :</span><span class="hl-0"> </span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span>
</code></pre>
<p>A special case of</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">click</span><span class="hl-0">()</span>
</code></pre>
<p>is equivalent to <code>t.click([])</code> - clicking at the current cursor location.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> offset: <a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).click</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L989">siesta/src/siesta/simulate/UserAgent.tsx:989</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="doubleClick" class="tsd-anchor"></a><h3>double<wbr/>Click</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">double<wbr/>Click<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, offset<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li><li class="tsd-signature tsd-kind-icon">double<wbr/>Click<span class="tsd-signature-symbol">(</span>options<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).doubleClick</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1084">siesta/src/siesta/simulate/UserAgent.tsx:1084</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates a double click on the given <a href="../modules/browser._internal_.html#ActionTarget">ActionTarget</a> at the given <a href="../modules/browser._internal_.html#ActionTargetOffset">ActionTargetOffset</a> point. If offset is not provided
the action happens in the center of the visible part of the target element.</p>
</div><div><p>Before performing an action, Siesta waits for the target element to <a href="../modules/Guide__Auto_waiting.html#AutoWaitingGuide">become actionable</a>
and synchronize the cursor position.</p>
<p>This method has 2 overloads and <code>target</code> and <code>offset</code> can be given either as positional arguments, or in the form
of the <a href="../modules/browser._internal_.html#MouseActionOptions">MouseActionOptions</a> object.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">doubleClick</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ])</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">doubleClick</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, { </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">doubleClick</span><span class="hl-0">({ </span><span class="hl-2">target :</span><span class="hl-0"> </span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span>
</code></pre>
<p>A special case of</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">doubleClick</span><span class="hl-0">()</span>
</code></pre>
<p>is equivalent to <code>t.doubleClick([])</code> - clicking at the current cursor location.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> offset: <a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).doubleClick</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1085">siesta/src/siesta/simulate/UserAgent.tsx:1085</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="dragBy" class="tsd-anchor"></a><h3>drag<wbr/>By</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">drag<wbr/>By<span class="tsd-signature-symbol">(</span>source<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, delta<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#Point" class="tsd-signature-type" data-tsd-kind="Type alias">Point</a>, options<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../interfaces/browser._internal_.DragActionOptions.html" class="tsd-signature-type" data-tsd-kind="Interface">DragActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).dragBy</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1340">siesta/src/siesta/simulate/UserAgent.tsx:1340</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates a drag action, from the given <code>source</code> element, by the given delta.</p>
</div><div><p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">dragBy</span><span class="hl-0">(</span><span class="hl-4">&#39;#source&#39;</span><span class="hl-0">, [ </span><span class="hl-7">10</span><span class="hl-0">, </span><span class="hl-7">20</span><span class="hl-0"> ], { </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">dragBy</span><span class="hl-0">([], [ </span><span class="hl-7">10</span><span class="hl-0">, </span><span class="hl-7">20</span><span class="hl-0"> ], { </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> }) </span><span class="hl-5">// drag from current cursor position</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>source: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>delta: <a href="../modules/browser._internal_.html#Point" class="tsd-signature-type" data-tsd-kind="Type alias">Point</a></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../interfaces/browser._internal_.DragActionOptions.html" class="tsd-signature-type" data-tsd-kind="Interface">DragActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="dragTo" class="tsd-anchor"></a><h3>drag<wbr/>To</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">drag<wbr/>To<span class="tsd-signature-symbol">(</span>options<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../interfaces/browser._internal_.DragActionOptions.html" class="tsd-signature-type" data-tsd-kind="Interface">DragActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li><li class="tsd-signature tsd-kind-icon">drag<wbr/>To<span class="tsd-signature-symbol">(</span>source<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, options<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../interfaces/browser._internal_.DragActionOptions.html" class="tsd-signature-type" data-tsd-kind="Interface">DragActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).dragTo</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1299">siesta/src/siesta/simulate/UserAgent.tsx:1299</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates a drag action, from the <code>source</code> element, to the <code>target</code> element</p>
</div><div><p>This method has several overloads and <code>source</code> and <code>target</code> can be provided either as positional arguments, or
as properties of the <a href="../interfaces/browser._internal_.DragActionOptions.html">DragActionOptions</a> object.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">dragTo</span><span class="hl-0">(</span><span class="hl-4">&#39;#source&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;#target&#39;</span><span class="hl-0">, { </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">dragTo</span><span class="hl-0">({ </span><span class="hl-2">source :</span><span class="hl-0"> </span><span class="hl-4">&#39;#source&#39;</span><span class="hl-0">, </span><span class="hl-2">target :</span><span class="hl-0"> </span><span class="hl-4">&#39;#target&#39;</span><span class="hl-0">, </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../interfaces/browser._internal_.DragActionOptions.html" class="tsd-signature-type" data-tsd-kind="Interface">DragActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).dragTo</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1300">siesta/src/siesta/simulate/UserAgent.tsx:1300</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>source: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../interfaces/browser._internal_.DragActionOptions.html" class="tsd-signature-type" data-tsd-kind="Interface">DragActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="keyDown" class="tsd-anchor"></a><h3>key<wbr/>Down</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">key<wbr/>Down<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, key<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).keyDown</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1447">siesta/src/siesta/simulate/UserAgent.tsx:1447</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates a key down action on the given <code>target</code> element.</p>
</div><div><p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">keyDown</span><span class="hl-0">(</span><span class="hl-4">&#39;#source&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;s&#39;</span><span class="hl-0">)</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>key: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="keyPress" class="tsd-anchor"></a><h3>key<wbr/>Press</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">key<wbr/>Press<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, key<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, options<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#KeyboardActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">KeyboardActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).keyPress</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1419">siesta/src/siesta/simulate/UserAgent.tsx:1419</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates a single key press on the given <code>target</code> element.</p>
</div><div><p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">keyPress</span><span class="hl-0">(</span><span class="hl-4">&#39;#source&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;s&#39;</span><span class="hl-0">, { </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>key: <span class="tsd-signature-type">string</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#KeyboardActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">KeyboardActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="keyUp" class="tsd-anchor"></a><h3>key<wbr/>Up</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">key<wbr/>Up<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, key<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).keyUp</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1473">siesta/src/siesta/simulate/UserAgent.tsx:1473</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates a key up action on the given <code>target</code> element.</p>
</div><div><p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">keyUp</span><span class="hl-0">(</span><span class="hl-4">&#39;#source&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;s&#39;</span><span class="hl-0">)</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>key: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="mouseDown" class="tsd-anchor"></a><h3>mouse<wbr/>Down</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">mouse<wbr/>Down<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, offset<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li><li class="tsd-signature tsd-kind-icon">mouse<wbr/>Down<span class="tsd-signature-symbol">(</span>options<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).mouseDown</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1131">siesta/src/siesta/simulate/UserAgent.tsx:1131</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates a &quot;mouse down&quot; action on the given <a href="../modules/browser._internal_.html#ActionTarget">ActionTarget</a> at the given <a href="../modules/browser._internal_.html#ActionTargetOffset">ActionTargetOffset</a> point. If offset is not provided
the action happens in the center of the visible part of the target element.</p>
</div><div><p>Before performing an action, Siesta waits for the target element to <a href="../modules/Guide__Auto_waiting.html#AutoWaitingGuide">become actionable</a>
and synchronize the cursor position.</p>
<p>This method has 2 overloads and <code>target</code> and <code>offset</code> can be given either as positional arguments, or in the form
of the <a href="../modules/browser._internal_.html#MouseActionOptions">MouseActionOptions</a> object.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">mouseDown</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ])</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">mouseDown</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, { </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">mouseDown</span><span class="hl-0">({ </span><span class="hl-2">target :</span><span class="hl-0"> </span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span>
</code></pre>
<p>A special case of</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">mouseDown</span><span class="hl-0">()</span>
</code></pre>
<p>is equivalent to <code>t.mouseDown([])</code> - clicking at the current cursor location.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> offset: <a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).mouseDown</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1132">siesta/src/siesta/simulate/UserAgent.tsx:1132</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="mouseUp" class="tsd-anchor"></a><h3>mouse<wbr/>Up</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">mouse<wbr/>Up<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, offset<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li><li class="tsd-signature tsd-kind-icon">mouse<wbr/>Up<span class="tsd-signature-symbol">(</span>options<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).mouseUp</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1179">siesta/src/siesta/simulate/UserAgent.tsx:1179</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates a &quot;mouse up&quot; action on the given <a href="../modules/browser._internal_.html#ActionTarget">ActionTarget</a> at the given <a href="../modules/browser._internal_.html#ActionTargetOffset">ActionTargetOffset</a> point. If offset is not provided
the action happens in the center of the visible part of the target element.</p>
</div><div><p>Before performing an action, Siesta waits for the target element to <a href="../modules/Guide__Auto_waiting.html#AutoWaitingGuide">become actionable</a>
and synchronize the cursor position.</p>
<p>This method has 2 overloads and <code>target</code> and <code>offset</code> can be given either as positional arguments, or in the form
of the <a href="../modules/browser._internal_.html#MouseActionOptions">MouseActionOptions</a> object.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">mouseUp</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ])</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">mouseUp</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, { </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">mouseUp</span><span class="hl-0">({ </span><span class="hl-2">target :</span><span class="hl-0"> </span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span>
</code></pre>
<p>A special case of</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">mouseUp</span><span class="hl-0">()</span>
</code></pre>
<p>is equivalent to <code>t.mouseUp([])</code> - clicking at the current cursor location.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> offset: <a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).mouseUp</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1180">siesta/src/siesta/simulate/UserAgent.tsx:1180</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="moveMouseBy" class="tsd-anchor"></a><h3>move<wbr/>Mouse<wbr/>By</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">move<wbr/>Mouse<wbr/>By<span class="tsd-signature-symbol">(</span>dx<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span>, dy<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span>, options<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li><li class="tsd-signature tsd-kind-icon">move<wbr/>Mouse<wbr/>By<span class="tsd-signature-symbol">(</span>delta<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#Point" class="tsd-signature-type" data-tsd-kind="Type alias">Point</a>, options<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).moveMouseBy</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1268">siesta/src/siesta/simulate/UserAgent.tsx:1268</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates a relative &quot;mouse move&quot; action, from the current position, by the given delta.</p>
</div><div><p>This method has several overloads and <code>delta</code> can be provided either as a <a href="../modules/browser._internal_.html#Point">Point</a> or 2 positional arguments.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">moveMouseBy</span><span class="hl-0">(</span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0">)</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">moveMouseBy</span><span class="hl-0">([ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], { </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>dx: <span class="tsd-signature-type">number</span></h5></li><li><h5>dy: <span class="tsd-signature-type">number</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).moveMouseBy</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1269">siesta/src/siesta/simulate/UserAgent.tsx:1269</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>delta: <a href="../modules/browser._internal_.html#Point" class="tsd-signature-type" data-tsd-kind="Type alias">Point</a></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="moveMouseTo" class="tsd-anchor"></a><h3>move<wbr/>Mouse<wbr/>To</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">move<wbr/>Mouse<wbr/>To<span class="tsd-signature-symbol">(</span>x<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span>, y<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">number</span>, options<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li><li class="tsd-signature tsd-kind-icon">move<wbr/>Mouse<wbr/>To<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, offset<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li><li class="tsd-signature tsd-kind-icon">move<wbr/>Mouse<wbr/>To<span class="tsd-signature-symbol">(</span>options<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">any</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).moveMouseTo</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1223">siesta/src/siesta/simulate/UserAgent.tsx:1223</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates &quot;mouse move&quot; action to the given <a href="../modules/browser._internal_.html#ActionTarget">ActionTarget</a> at the given <a href="../modules/browser._internal_.html#ActionTargetOffset">ActionTargetOffset</a> point. If offset is not provided,
cursor moves to the center of the visible part of the target element.</p>
</div><div><p>Before performing mouse move, Siesta waits for the target element to <a href="../modules/Guide__Auto_waiting.html#AutoWaitingGuide">become actionable</a>.</p>
<p>This method has several overloads and <code>target</code> and <code>offset</code> can be given either as positional arguments, or in the form
of the <a href="../modules/browser._internal_.html#MouseActionOptions">MouseActionOptions</a> object.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">moveMouseTo</span><span class="hl-0">(</span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0">)</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">moveMouseTo</span><span class="hl-0">([ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ])</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">moveMouseTo</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ])</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">moveMouseTo</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, { </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">moveMouseTo</span><span class="hl-0">({ </span><span class="hl-2">target :</span><span class="hl-0"> </span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>x: <span class="tsd-signature-type">number</span></h5></li><li><h5>y: <span class="tsd-signature-type">number</span></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).moveMouseTo</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1224">siesta/src/siesta/simulate/UserAgent.tsx:1224</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> offset: <a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).moveMouseTo</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1225">siesta/src/siesta/simulate/UserAgent.tsx:1225</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">any</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="rightClick" class="tsd-anchor"></a><h3>right<wbr/>Click</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">right<wbr/>Click<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, offset<span class="tsd-signature-symbol">?: </span><a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li><li class="tsd-signature tsd-kind-icon">right<wbr/>Click<span class="tsd-signature-symbol">(</span>options<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).rightClick</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1036">siesta/src/siesta/simulate/UserAgent.tsx:1036</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates a right click on the given <a href="../modules/browser._internal_.html#ActionTarget">ActionTarget</a> at the given <a href="../modules/browser._internal_.html#ActionTargetOffset">ActionTargetOffset</a> point. If offset is not provided
the action happens in the center of the visible part of the target element.</p>
</div><div><p>Before performing an action, Siesta waits for the target element to <a href="../modules/Guide__Auto_waiting.html#AutoWaitingGuide">become actionable</a>
and synchronize the cursor position.</p>
<p>This method has 2 overloads and <code>target</code> and <code>offset</code> can be given either as positional arguments, or in the form
of the <a href="../modules/browser._internal_.html#MouseActionOptions">MouseActionOptions</a> object.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">rightClick</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ])</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">rightClick</span><span class="hl-0">(</span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, { </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span><br/><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">rightClick</span><span class="hl-0">({ </span><span class="hl-2">target :</span><span class="hl-0"> </span><span class="hl-4">&#39;.css-class .another-css.class&#39;</span><span class="hl-0">, </span><span class="hl-2">offset :</span><span class="hl-0"> [ </span><span class="hl-7">30</span><span class="hl-0">, </span><span class="hl-7">40</span><span class="hl-0"> ], </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span>
</code></pre>
<p>A special case of</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">rightClick</span><span class="hl-0">()</span>
</code></pre>
<p>is equivalent to <code>t.rightClick([])</code> - clicking at the current cursor location.</p>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> offset: <a href="../modules/browser._internal_.html#ActionTargetOffset" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTargetOffset</a><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).rightClick</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1037">siesta/src/siesta/simulate/UserAgent.tsx:1037</a></li></ul></aside><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#MouseActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">MouseActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section><section class="tsd-panel tsd-member tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a id="type" class="tsd-anchor"></a><h3>type</h3><ul class="tsd-signatures tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><li class="tsd-signature tsd-kind-icon">type<span class="tsd-signature-symbol">(</span>target<span class="tsd-signature-symbol">: </span><a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a>, text<span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">string</span>, options<span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#KeyboardActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">KeyboardActionOptions</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">: </span><span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></li></ul><ul class="tsd-descriptions"><li class="tsd-description"><aside class="tsd-sources"><p>Inherited from Mixin(
    [
        UserAgentOnPage,
        AssertionObservable,
        AssertionElement,
        TextSelectionHelpers,
        ExecutionContextAttachableBrowser,
        Test
    ],
    (base : ClassUnion&lt;
        typeof UserAgentOnPage,
        typeof AssertionObservable,
        typeof AssertionElement,
        typeof TextSelectionHelpers,
        typeof ExecutionContextAttachableBrowser,
        typeof Test
    &gt;) =&gt;

    class TestBrowser extends base {
        // allow the browser test initialize w/o exception even in Node.js environment
        // (we&#39;ll issue a meaningful error in this case later)
        window                  : Window                        = typeof window !== &#39;undefined&#39; ? window : undefined

        @prototypeValue(TestDescriptorBrowser)
        testDescriptorClass     : typeof TestDescriptorBrowser

        descriptor          : TestDescriptorBrowser

        // @prototypeValue(ExecutionContextBrowser)
        // executionContextClass   : typeof ExecutionContext

        connector           : TestLauncherChild &amp; Simulator

        mouseCursorVisualizer   : MouseCursorVisualizer     = MouseCursorVisualizer.new()


        addListenerToObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.addEventListener(event, listener)
        }


        removeListenerFromObservable (observable : unknown, event : string, listener : AnyFunction) {
            // @ts-ignore
            observable.removeEventListener(event, listener)
        }


        resolveObservable (source : ActionTarget) : unknown {
            return this.resolveActionTarget(source)
        }


        get onAmbiguousQuery () : &#39;use_first&#39; | &#39;warn&#39; | &#39;throw&#39; {
            return this.descriptor.onAmbiguousQuery
        }


        get mouseMovePrecision () : PointerMovePrecision {
            return this.descriptor.mouseMovePrecision
        }


        // @ts-expect-error
        get simulator () : Simulator {
            return this.connector
        }
        set simulator (value : Simulator) {
        }


        async setupPreloads () {
            await awaitDomInteractive()

            // TODO clean this up once the support for in-test config is implemented
            // there&#39;s now pre-normalization step in the &quot;flatten&quot; method,
            // which converts all `PreloadDescriptor`s to `PreloadDescriptorNormalized`
            // and &quot;absolutize&quot; their `url`s, so it seems these conversions are not needed
            // even though they are not harmful (since every `PreloadDescriptorNormalized`
            // is also a regular `PreloadDescriptor`)
            const preloads      = wantArray(this.descriptor.preload || [])
                .concat(this.descriptor.preloadRel || [])
                .concat(this.descriptor.alsoPreload || [])
                .flat(2000)
                .filter(el =&gt; Boolean(el))
                .map(normalizePreloadDescriptor)

            const doc   = this.window.document

            const waitFor : Promise&lt;Event | undefined&gt;[]        = []

            for (const preload of preloads) {
                if (preload.type === &#39;js&#39;) {
                    const el    = doc.createElement(&#39;script&#39;)

                    // @ts-ignore
                    el.PRELOAD  = true

                    el.type = preload.isEcmaModule ? &#39;module&#39; : &#39;text/javascript&#39;
                    preload.isEcmaModule &amp;&amp; el.setAttribute(&quot;crossorigin&quot;, &quot;anonymous&quot;)

                    if (&#39;url&#39; in preload) {
                        // TODO clean this up, see note above
                        // el.src = new URL(preload.url, this.descriptor.urlAbs).href
                        el.src = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))
                    }
                    else
                        el.text = preload.content

                    doc.head.appendChild(el)
                }
                else {
                    if (&#39;url&#39; in preload) {
                        const el    = doc.createElement(&#39;link&#39;)

                        // @ts-ignore
                        el.PRELOAD  = true

                        el.type     = &#39;text/css&#39;
                        el.rel      = &#39;stylesheet&#39;
                        // TODO clean this up, see note above
                        // el.href     = new URL(preload.url, this.descriptor.urlAbs).href
                        el.href     = preload.url

                        waitFor.push(new Promise((resolve, reject) =&gt; {
                            el.addEventListener(&#39;load&#39;, () =&gt; resolve(undefined))
                            el.addEventListener(&#39;error&#39;, resolve)
                        }))

                        doc.head.appendChild(el)
                    }
                    else {
                        const el    = doc.createElement(&#39;style&#39;)

                        el.setAttribute(&quot;type&quot;, &#39;text/css&#39;)

                        el.appendChild(document.createTextNode(preload.content))

                        doc.head.appendChild(el)
                    }
                }
            }

            const results   = await Promise.all(waitFor)

            for (const result of results) {
                if (result) {
                    const target    = result.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource preloading failure&#39;,
                        passed      : false,
                        annotation  : url
                            ? &lt;div&gt;
                                Preloading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Preloading of the resource has failed.
                            &lt;/div&gt;
                    }))
                }
            }
        }


        override async setupExecutionContext () {
            await super.setupExecutionContext()

            if (this.descriptor.failOnResourceLoadError)
                this.onResourceLoadFailureHook.on((me : TestBrowser, event : Event) =&gt; {
                    // ignore the loading errors from the elements, that were created by the preload mechanism -
                    // it has its own error reporting
                    // @ts-ignore
                    if (event.target.PRELOAD) return

                    const target    = event.target

                    const url       = target
                        ? isHTMLScriptElement(target)
                            ? target.src
                            : isHTMLLinkElement(target)
                                ? target.href
                                : undefined
                        : undefined

                    this.addResult(Assertion.new({
                        name        : &#39;Resource loading failure&#39;,
                        passed      : false,
                        // TODO, should probably include serialized element to the annotation
                        annotation  : url
                            ? &lt;div&gt;
                                Loading of the `{ url }` has failed
                            &lt;/div&gt;
                            : &lt;div&gt;
                                Loading of the resource has failed.
                            &lt;/div&gt;
                    }))
                })
        }


        override async setupRootTest () {
            const superSetup            = super.setupRootTest()
            const mouseCursorVisStart   = this.mouseCursorVisualizer.start()

            const doc   = this.window.document

            if (this.descriptor.expandBody) {
                const html      = doc.documentElement
                const body      = doc.body

                body.style.width    = html.style.width  = &#39;100%&#39;
                body.style.height   = html.style.height = &#39;100%&#39;
                body.style.margin   = body.style.padding = &#39;0&#39;
            }

            let mousePositionRestore    = Promise.resolve()

            if (this.dashboardLaunchInfo) {
                // @ts-expect-error
                this.simulator.offset   = this.dashboardLaunchInfo.offset

                mousePositionRestore    = await this.simulator.simulateMouseMove([ 0, 0 ], { mouseMovePrecision : { kind : &#39;last_only&#39;, precision : 1 } })
            }

            // this will await until the `super` method installs the ExecutionContext hooks
            await superSetup

            await Promise.all([ mouseCursorVisStart, mousePositionRestore, this.setupPreloads() ])
        }


        async launch (checkInfo : SubTestCheckInfo = undefined) {
            if (!this.parentNode &amp;&amp; this.window.document.compatMode === &#39;BackCompat&#39;) {
                this.addResult(Exception.new({ exception : new Error(&#39;Test page is opened in the quirks mode&#39;) }))
                return
            }

            await super.launch(checkInfo)
        }


        async tearDownRootTest () {
            await super.tearDownRootTest()

            this.mouseCursorVisualizer.stop()
        }


        getElementAtCursor (deep : boolean = true) : Element {
            return elementFromPoint(this.window.document, ...this.simulator.currentPosition, deep).el
        }


        static async getExecutionContextClass () : Promise&lt;typeof ExecutionContext&gt; {
            return ExecutionContextBrowser
        }


        static async getLauncherClass () : Promise&lt;typeof Launcher&gt; {
            return (await import(&#39;../launcher/LauncherBrowser.js&#39;)).LauncherBrowser
        }


        // TODO refactor the whole launching infrastructure
        static async launchStandalone () {
            if (isNodejs()) {
                const styles                = (await import(&quot;../reporter/styling/theme_universal.js&quot;)).styles
                const colorerClass          = (await import(&#39;../../jsx/ColorerNodejs.js&#39;)).ColorerNodejs
                const c                     = colorerClass.new()
                const style                 = (clsName : string) =&gt; styles.get(clsName)(c)

                console.log(
`${ style(&#39;exception_icon&#39;).text(&#39; ERROR &#39;) } Browser test launched directly as Node.js script.
Please use Siesta launcher instead and web url:
  ${ style(&#39;accented&#39;).text(&#39;npx siesta http://web_path/to/your/test.js&#39;) }`
                )

                process.exitCode            = ExitCodes.INCORRECT_ENVIRONMENT

                return
            } else
                super.launchStandalone()
        }
    }

).type</p><ul><li>Defined in <a href="https://github.com/bryntum/siesta/blob/a50d6be/packages/siesta/src/siesta/simulate/UserAgent.tsx#L1390">siesta/src/siesta/simulate/UserAgent.tsx:1390</a></li></ul></aside><div class="tsd-comment tsd-typography"><div class="lead">
<p>Simulates keyboard typing on the given <code>target</code> element. Performs all actions that a real user would do,
including pressing and releasing a keyboard button for every character.</p>
</div><div><p>If target is provided as <code>[]</code> or <code>null</code>, the typing will be performed on the currently focused element.
Otherwise, target will be resolved and focused.</p>
<p>Simulation of pressing the special keys is supported. You can specify them, by using their all uppercased
key name inside the square brackets: <code>[ENTER]</code>, <code>[BACKSPACE]</code>, <code>[LEFT]</code>. To type <code>[ENTER]</code> as plain text and not as
a special character - use double square brackets: <code>[[ENTER]</code><span>]</span>. The full list of special key names is
<a href="../modules/Guide__Special_key_names.html#KeyNamesGuide">available here</a>.</p>
<p>To specify a control key like &quot;SHIFT / CONTROL / ALT / META&quot; of to be pressed during typing, use the <code>options</code>
argument.</p>
<p>For example:</p>
<pre><code class="language-javascript"><span class="hl-1">await</span><span class="hl-0"> </span><span class="hl-2">t</span><span class="hl-0">.</span><span class="hl-3">type</span><span class="hl-0">(</span><span class="hl-4">&#39;#source&#39;</span><span class="hl-0">, </span><span class="hl-4">&#39;some text[ENTER]&#39;</span><span class="hl-0">, { </span><span class="hl-2">ctrlKey :</span><span class="hl-0"> </span><span class="hl-6">true</span><span class="hl-0"> })</span>
</code></pre>
</div></div><h4 class="tsd-parameters-title">Parameters</h4><ul class="tsd-parameters"><li><h5>target: <a href="../modules/browser._internal_.html#ActionTarget" class="tsd-signature-type" data-tsd-kind="Type alias">ActionTarget</a></h5></li><li><h5>text: <span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>The text to type</p>
</div></div></li><li><h5><span class="tsd-flag ts-flagOptional">Optional</span> options: <span class="tsd-signature-type">Partial</span><span class="tsd-signature-symbol">&lt;</span><a href="../modules/browser._internal_.html#KeyboardActionOptions" class="tsd-signature-type" data-tsd-kind="Type alias">KeyboardActionOptions</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><div class="lead">
<p>Additional options for the action</p>
</div></div></li></ul><h4 class="tsd-returns-title">Returns <span class="tsd-signature-type">Promise</span><span class="tsd-signature-symbol">&lt;</span><span class="tsd-signature-type">any</span><span class="tsd-signature-symbol">&gt;</span></h4></li></ul></section></section></div><div class="col-4 col-menu menu-sticky-wrap menu-highlight"><nav class="tsd-navigation primary"><ul><li class=""><a href="../modules.html">Modules</a></li><li class=" tsd-kind-module"><a href="../modules/Guide__Auto_waiting.html">Guide: <wbr/>Auto waiting</a></li><li class=" tsd-kind-module"><a href="../modules/Guide__Getting_started_Deno.html">Guide: <wbr/>Getting started <wbr/>Deno</a></li><li class=" tsd-kind-module"><a href="../modules/Guide__Getting_started_Node_js.html">Guide: <wbr/>Getting started <wbr/>Node.js</a></li><li class=" tsd-kind-module"><a href="../modules/Guide__Getting_started_Sencha.html">Guide: <wbr/>Getting started <wbr/>Sencha</a></li><li class=" tsd-kind-module"><a href="../modules/Guide__Getting_started_browser.html">Guide: <wbr/>Getting started browser</a></li><li class=" tsd-kind-module"><a href="../modules/Guide__Reports.html">Guide: <wbr/>Reports</a></li><li class=" tsd-kind-module"><a href="../modules/Guide__Siesta_project.html">Guide: <wbr/>Siesta project</a></li><li class=" tsd-kind-module"><a href="../modules/Guide__Special_key_names.html">Guide: <wbr/>Special key names</a></li><li class=" tsd-kind-module"><a href="../modules/Guide__Testing_advanced.html">Guide: <wbr/>Testing advanced</a></li><li class=" tsd-kind-module"><a href="../modules/Guide__Testing_basics.html">Guide: <wbr/>Testing basics</a></li><li class="current tsd-kind-module"><a href="../modules/browser.html">browser</a><ul><li class=" tsd-kind-namespace tsd-parent-kind-module"><a href="../modules/browser._internal_.html">&lt;internal&gt;</a></li></ul></li><li class=" tsd-kind-module"><a href="../modules/deno.html">deno</a></li><li class=" tsd-kind-module"><a href="../modules/index.html">index</a></li><li class=" tsd-kind-module"><a href="../modules/nodejs.html">nodejs</a></li><li class=" tsd-kind-module"><a href="../modules/sencha.html">sencha</a></li></ul></nav><nav class="tsd-navigation secondary menu-sticky"><ul><li class="current tsd-kind-class tsd-parent-kind-module"><a href="browser.TestBrowser.html" class="tsd-kind-icon">Test<wbr/>Browser</a><ul><li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#constructor" class="tsd-kind-icon">constructor</a></li><li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#logLevel" class="tsd-kind-icon">log<wbr/>Level</a></li><li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#testDescriptorClass" class="tsd-kind-icon">test<wbr/>Descriptor<wbr/>Class</a></li><li class="tsd-kind-get-signature tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#not" class="tsd-kind-icon">not</a></li><li class="tsd-kind-get-signature tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#silent" class="tsd-kind-icon">silent</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#_" class="tsd-kind-icon">$</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#__" class="tsd-kind-icon">$$</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#afterEach" class="tsd-kind-icon">after<wbr/>Each</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#any" class="tsd-kind-icon">any</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#anyNumberApprox" class="tsd-kind-icon">any<wbr/>Number<wbr/>Approx</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#anyStringLike" class="tsd-kind-icon">any<wbr/>String<wbr/>Like</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#beforeEach" class="tsd-kind-icon">before<wbr/>Each</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#beginAsync" class="tsd-kind-icon">begin<wbr/>Async</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#click" class="tsd-kind-icon">click</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#contain" class="tsd-kind-icon">contain</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#createSpy" class="tsd-kind-icon">create<wbr/>Spy</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#createSpyObj" class="tsd-kind-icon">create<wbr/>Spy<wbr/>Obj</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#ddescribe" class="tsd-kind-icon">ddescribe</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#debug" class="tsd-kind-icon">debug</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#describe" class="tsd-kind-icon">describe</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#doesNotThrow" class="tsd-kind-icon">does<wbr/>Not<wbr/>Throw</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#doubleClick" class="tsd-kind-icon">double<wbr/>Click</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#dragBy" class="tsd-kind-icon">drag<wbr/>By</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#dragTo" class="tsd-kind-icon">drag<wbr/>To</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#elementPointIsReachable" class="tsd-kind-icon">element<wbr/>Point<wbr/>Is<wbr/>Reachable</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#elementValueIs" class="tsd-kind-icon">element<wbr/>Value<wbr/>Is</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#endAsync" class="tsd-kind-icon">end<wbr/>Async</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#eq" class="tsd-kind-icon">eq</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#equal" class="tsd-kind-icon">equal</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#error" class="tsd-kind-icon">error</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#expect" class="tsd-kind-icon">expect</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#false" class="tsd-kind-icon">false</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#firesAtLeastNTimes" class="tsd-kind-icon">fires<wbr/>At<wbr/>LeastNTimes</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#firesOk" class="tsd-kind-icon">fires<wbr/>Ok</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#firesOnce" class="tsd-kind-icon">fires<wbr/>Once</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#getCaretPosition" class="tsd-kind-icon">get<wbr/>Caret<wbr/>Position</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#getSelectedText" class="tsd-kind-icon">get<wbr/>Selected<wbr/>Text</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#iit" class="tsd-kind-icon">iit</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#info" class="tsd-kind-icon">info</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#initialize" class="tsd-kind-icon">initialize</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#is" class="tsd-kind-icon">is</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isApprox" class="tsd-kind-icon">is<wbr/>Approx</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isArray" class="tsd-kind-icon">is<wbr/>Array</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isBoolean" class="tsd-kind-icon">is<wbr/>Boolean</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isCalled" class="tsd-kind-icon">is<wbr/>Called</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isCalledNTimes" class="tsd-kind-icon">is<wbr/>CalledNTimes</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isCalledOnce" class="tsd-kind-icon">is<wbr/>Called<wbr/>Once</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isDate" class="tsd-kind-icon">is<wbr/>Date</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isDeeply" class="tsd-kind-icon">is<wbr/>Deeply</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isFunction" class="tsd-kind-icon">is<wbr/>Function</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isGE" class="tsd-kind-icon">isGE</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isGreater" class="tsd-kind-icon">is<wbr/>Greater</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isGreaterOrEqual" class="tsd-kind-icon">is<wbr/>Greater<wbr/>Or<wbr/>Equal</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isInstanceOf" class="tsd-kind-icon">is<wbr/>Instance<wbr/>Of</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isLE" class="tsd-kind-icon">isLE</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isLess" class="tsd-kind-icon">is<wbr/>Less</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isLessOrEqual" class="tsd-kind-icon">is<wbr/>Less<wbr/>Or<wbr/>Equal</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isMap" class="tsd-kind-icon">is<wbr/>Map</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isNot" class="tsd-kind-icon">is<wbr/>Not</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isNumber" class="tsd-kind-icon">is<wbr/>Number</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isObject" class="tsd-kind-icon">is<wbr/>Object</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isRegExp" class="tsd-kind-icon">is<wbr/>Reg<wbr/>Exp</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isSet" class="tsd-kind-icon">is<wbr/>Set</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isStrict" class="tsd-kind-icon">is<wbr/>Strict</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isString" class="tsd-kind-icon">is<wbr/>String</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isWeakMap" class="tsd-kind-icon">is<wbr/>Weak<wbr/>Map</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isWeakSet" class="tsd-kind-icon">is<wbr/>Weak<wbr/>Set</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#isntCalled" class="tsd-kind-icon">isnt<wbr/>Called</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#isntFired" class="tsd-kind-icon">isnt<wbr/>Fired</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#it" class="tsd-kind-icon">it</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#keyDown" class="tsd-kind-icon">key<wbr/>Down</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#keyPress" class="tsd-kind-icon">key<wbr/>Press</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#keyUp" class="tsd-kind-icon">key<wbr/>Up</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#livesOk" class="tsd-kind-icon">lives<wbr/>Ok</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#log" class="tsd-kind-icon">log</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#match" class="tsd-kind-icon">match</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#methodIsCalled" class="tsd-kind-icon">method<wbr/>Is<wbr/>Called</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#methodIsCalledNTimes" class="tsd-kind-icon">method<wbr/>Is<wbr/>CalledNTimes</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#methodIsntCalled" class="tsd-kind-icon">method<wbr/>Isnt<wbr/>Called</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#mouseDown" class="tsd-kind-icon">mouse<wbr/>Down</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#mouseUp" class="tsd-kind-icon">mouse<wbr/>Up</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#moveCaretPosition" class="tsd-kind-icon">move<wbr/>Caret<wbr/>Position</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#moveMouseBy" class="tsd-kind-icon">move<wbr/>Mouse<wbr/>By</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#moveMouseTo" class="tsd-kind-icon">move<wbr/>Mouse<wbr/>To</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#ne" class="tsd-kind-icon">ne</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#notContain" class="tsd-kind-icon">not<wbr/>Contain</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#notEqual" class="tsd-kind-icon">not<wbr/>Equal</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#notMatch" class="tsd-kind-icon">not<wbr/>Match</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#notOk" class="tsd-kind-icon">not<wbr/>Ok</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#ok" class="tsd-kind-icon">ok</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#query" class="tsd-kind-icon">query</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#querySingleContext" class="tsd-kind-icon">query<wbr/>Single<wbr/>Context</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#resolveObservable" class="tsd-kind-icon">resolve<wbr/>Observable</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#rightClick" class="tsd-kind-icon">right<wbr/>Click</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#selectText" class="tsd-kind-icon">select<wbr/>Text</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#selectorExists" class="tsd-kind-icon">selector<wbr/>Exists</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#setCaretPosition" class="tsd-kind-icon">set<wbr/>Caret<wbr/>Position</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#spyOn" class="tsd-kind-icon">spy<wbr/>On</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#throws" class="tsd-kind-icon">throws</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#throwsOk" class="tsd-kind-icon">throws<wbr/>Ok</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#todo" class="tsd-kind-icon">todo</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#true" class="tsd-kind-icon">true</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#type" class="tsd-kind-icon">type</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited"><a href="browser.TestBrowser.html#waitFor" class="tsd-kind-icon">wait<wbr/>For</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#waitForEvent" class="tsd-kind-icon">wait<wbr/>For<wbr/>Event</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#waitForSelector" class="tsd-kind-icon">wait<wbr/>For<wbr/>Selector</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#waitForSelectors" class="tsd-kind-icon">wait<wbr/>For<wbr/>Selectors</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#warn" class="tsd-kind-icon">warn</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#willFireNTimes" class="tsd-kind-icon">will<wbr/>FireNTimes</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#wontFire" class="tsd-kind-icon">wont<wbr/>Fire</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><a href="browser.TestBrowser.html#xit" class="tsd-kind-icon">xit</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#ddescribe-1" class="tsd-kind-icon">ddescribe</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#describe-1" class="tsd-kind-icon">describe</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#iit-1" class="tsd-kind-icon">iit</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#it-1" class="tsd-kind-icon">it</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#maybeNew" class="tsd-kind-icon">maybe<wbr/>New</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#new" class="tsd-kind-icon">new</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#xdescribe" class="tsd-kind-icon">xdescribe</a></li><li class="tsd-kind-method tsd-parent-kind-class tsd-has-type-parameter tsd-is-inherited tsd-is-static"><a href="browser.TestBrowser.html#xit-1" class="tsd-kind-icon">xit</a></li></ul></li></ul></nav></div></div></div><footer class="with-border-bottom"><div class="container"><h2>Legend</h2><div class="tsd-legend-group"><ul class="tsd-legend"><li class="tsd-kind-namespace"><span class="tsd-kind-icon">Namespace</span></li><li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li><li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li><li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li><li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li></ul></div><h2>Settings</h2><p>Theme <select id="theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></p></div></footer><div class="container tsd-generator"><p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div><div class="overlay"></div><script src="../assets/main.js"></script></body></html>